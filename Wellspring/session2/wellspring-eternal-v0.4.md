# Wellspring Eternal

**A Traversal-Based Model for Persistent Memory**

*Version 0.4 — January 2026*

---

## Abstract

Wellspring Eternal is a memory architecture for humans and artificial agents based on a single insight: **memory is not storage, memory is traversal history**.

Rather than treating recall as retrieval from a database, Wellspring models cognition as walking paths through a graph of thoughts. What surfaces to conscious attention isn't what's "important" in some absolute sense—it's what's **reachable from the current context** and **coherent enough to complete**.

The system requires only one primitive: **Thought**. A thought is a content-addressed node (CID) in a Merkle DAG. Everything—identities, connections, attestations, aspects, pools, trails—is a thought with typed content. What we call "memory" is the structure of references between thoughts, walked via `because` chains.

---

## What Is Wellspring?

Your computer buddy. Your external brain.

### The Basic Flow

Wellspring collects and records all the traces of information you surface throughout the day — amount controllable by you. Maybe it's just browser history. Maybe it's summaries of pages. The trick is: **you do you**. Carry on clicking around, reading things, asking questions, doing additional research, coming to conclusions.

By recording these trails and links as personal indexes, background agents work to make that information available to you again in the future: search indexing, summarisation, record linking. This is generated by bots, but then the bots present it to you along with their reasoning and sources. You say whether that makes sense to you or not, and record your current thoughts about it.

The bot takes your response and updates the links — attests you saw it and confirmed — recorded with your attestation so we're all in agreement. You can then summarise and record learnings, rules, or aspects of intelligence learned about the connections drawn through that line. You can start a new thread of connections off that, referencing back to the original.

### Private Until Published

Your thoughts are private until made public. They're shareable between interested parties in pools, which act as knowledge repos for shared things.

Once that summarised and considered output is ready, it can be published to a public pool or a shared pool. This is your basic tweet-level understanding stuff — you can put it out there, get feedback, responses positive and negative about various aspects of the thought, with people "liking" or disliking or contradicting your thought with their thought and their evidence chains.

Once you've assembled enough thoughts that have been reviewed, they can be turned into an article. But an article is just the connection saying "we all agree this is the finished piece."

### The Product Loop

```
CAPTURE     You do you — clicking, reading, researching
    ↓
INDEX       Background bots: index, link, summarize (cheap, local)
    ↓
PRESENT     "Here's what I found, here's my reasoning"
    ↓
ATTEST      You confirm/deny/refine, recorded with signature
    ↓
LEARN       Aspects, rules, connections updated
    ↓
BRANCH      New thread off this, referencing back
    ↓
PUBLISH     To pool when ready (tweet-level or article-level)
    ↓
FEEDBACK    Others attest positive/negative with their evidence
    ↓
SYNC        Updates flow to everyone's device
```

---

## Historical Context: Bush's Memex and the 80-Year Gap

### As We May Think (1945)

Vannevar Bush's essay "As We May Think" described the Memex—a device for building and sharing **associative trails** through information. His core insight remains unrealized 80 years later:

> "Our ineptitude in getting at the record is largely caused by the artificiality of systems of indexing. When data of any sort are placed in storage, they are filed alphabetically or numerically... It can be in only one place, unless duplicates are used."

Bush proposed selection by **association** rather than by **indexing**:

> "Selection by association, rather than by indexing, may yet be mechanized. One cannot hope thus to equal the speed and flexibility with which the mind follows an associative trail, but it should be possible to beat the mind decisively in regard to the permanence and clarity of the items resurrected from storage."

### What Bush Got Right

| Bush's Memex (1945) | Wellspring (2026) |
|---------------------|-------------------|
| "The process of tying two items together is the important thing" | Connection thoughts as typed relations |
| "When the user is building a trail, he names it" | Named trails via IPNS |
| "Any item can be joined into numerous trails" | Graph not tree (DAG) |
| "Trails that are not frequently followed are prone to fade" | Salience decay (heat model) |
| "He inserts a comment of his own, linking it into the main trail" | Attestation thoughts on connections |
| "Photographs the whole trail out, passes it to his friend" | Export/share traversal paths |
| "There is a new profession of trail blazers" | Curated pools with verified expertise |

### The Wrong Turn: Hyperlinks

The World Wide Web took a wrong turn from Bush's vision:

| Hyperlink (what we got) | Trail (what Bush wanted) |
|-------------------------|--------------------------|
| One-way | Bidirectional (via connection thoughts) |
| Untyped | Typed relation |
| No attribution | Who made this link (created_by) |
| No annotation | Why this link (because) |
| Decays (link rot) | Persists (your copy, content-addressed) |
| Can't share the path | Path is the artifact |

Wellspring completes Bush's vision: trails as first-class citizens, with trust, with AI, with multi-party collaboration.

---

## Core Insight

### The Problem with Storage Models

Traditional memory systems treat thoughts as objects to be stored and retrieved:

- Store fact X
- Index by attributes
- Query when needed
- Return matches

This fails to capture how memory actually works:

- The same fact can be inaccessible one moment and vivid the next
- "Knowing" something is different from "understanding" it
- Forgetting isn't deletion—it's losing the path
- Context determines what surfaces, not just relevance scores
- Trust in information depends on source and verification

### The Traversal Model

Wellspring reframes memory as graph traversal:

| Storage Model | Traversal Model |
|---------------|-----------------|
| Facts are stored | Thoughts exist in relation |
| Recall is retrieval | Recall is re-walking a path |
| Importance is intrinsic | Salience is positional |
| Forgetting is deletion | Forgetting is unreachability |
| Understanding is having data | Understanding is completed traversal |
| Trust is metadata | Trust emerges from attestation chains |

**Key principle**: A thought isn't "known" because it's stored. It's "understood" because you've walked to it and back, and the path made sense. It's "trusted" because the chain of attestations leads back to sources you trust.

---

## The Primitive

Wellspring has exactly one primitive: **Thought**.

### Thought as Merkle DAG Node

Every thought is a node in a Merkle DAG. Its identifier is a CID (Content Identifier) — the hash of its content.

```
Thought {
  cid:        hash(content + created_by + because)
  content:    typed payload (see Thought Types)
  created_by: identity_cid
  created_at: timestamp
  because:    [thought_cid, ...]    // what led to this thought
  signature:  sig(cid, creator_privkey)
}
```

**Properties**:

- **Immutable**: once created, content never changes
- **Content-addressed**: CID derived from content hash
- **Always attributed**: created_by is required, never null
- **Signed**: signature proves creator authenticity
- **Grounded**: `because` links to the thoughts that led here
- **Self-verified**: CID cryptographically proves content integrity

### The `because` Chain

Every thought can reference the thoughts that led to it:

```
because: [thought_cid, thought_cid, ...]
```

This is how trails form. Walk `because` backward and you traverse the reasoning path.

Could be:
- The article you read
- The attestation you agreed with
- The connection you noticed
- The aspect that was relevant
- Empty (ungrounded assertion, terminal node)

The DAG grows forward in time. Trails are read backward through `because`.

### Why One Primitive?

Two primitives (Thought + Connection) creates ambiguity: what is a connection, really? Where do attestations live? How do you attest a connection vs a thought?

One primitive resolves this: **everything is a thought**. Type is just content shape. A connection is a thought whose content describes a relation. An attestation is a thought whose content expresses belief. Both are CIDs. Both can be attested. Both can be in `because` chains.

---

## Thought Types

Types are not separate primitives — they're content schemas. The type determines how the thought is interpreted and queried.

### Basic Thought

Simple content. The leaf node.

```
{
  type: "basic"
  content: string | structured
}
```

Example: A note, a quote, a captured snippet, a summary.

### Identity Thought

A participant who can sign.

```
{
  type: "identity"
  name: string
  pubkey: ed25519_pubkey
}
```

**Special property**: Identity thoughts are self-referential. The `created_by` points to itself. Bootstrap via self-attestation.

```
Identity CID = hash({
  type: "identity",
  name: "Keif",
  pubkey: "ed25519:abc..."
} + SELF + [])

created_by: SELF → resolved to this CID
because: [] → terminal, self-asserted
signature: sig(cid, privkey)
```

### Connection Thought

A typed relationship between thoughts.

```
{
  type: "connection"
  from: thought_cid
  to: thought_cid
  relation: relation_type
}
```

**Core relations**:

| Relation | Meaning |
|----------|---------|
| `supports` | Evidence for |
| `contradicts` | Tension with |
| `continues` | Sequence/thread |
| `derives_from` | Source/provenance |
| `vouches` | Trust endorsement |
| `member_of` | Belongs to pool |
| `published_to` | Visible in pool |
| `instance_of` | Specific is type of general |
| `same_as` | Identity resolution |

Connections are themselves thoughts. They can be attested. They can appear in `because` chains. They can be connected to other connections.

### Attestation Thought

A signed belief about another thought.

```
{
  type: "attestation"
  on: thought_cid          // what you're attesting (any thought)
  via: aspect_cid | null   // through what lens
  weight: float [-1.0, 1.0]
}
```

**What can you attest?**

- A basic thought: "I believe this content" (+0.8)
- A connection: "I agree this relation holds" (+1.0)
- An attestation: "I agree with their judgement" (+0.7)
- An aspect: "This value applies to me" (+1.0)
- A pool: "This is a good pool" (+0.9)

The `because` chain grounds the attestation: "I believe this because of these thoughts."

**Constraints**: When `via` points to a constraint-type aspect and `weight` is -1.0, it's a veto.

### Aspect Thought

A value, preference, need, mood, or constraint.

```
{
  type: "aspect"
  aspect_type: value | preference | need | mood | constraint
  domain: string
  valence: positive | negative
  decay: duration | null
}
```

**Aspect types**:

| Type | Persistence | Example |
|------|-------------|---------|
| **value** | Core, permanent | `family-first` |
| **preference** | Flexible | `enjoys-spicy` |
| **need** | Situational | `wheelchair-accessible` |
| **mood** | Transient | `craving-chips` |
| **constraint** | Hard, binary | `vegetarian` |

Aspects are thoughts. They can be attested ("yes, this aspect applies to me"). They can be in `because` chains ("I chose this because of this value").

### Pool Thought

An organizational container. Everything lives in a pool.

```
{
  type: "pool"
  name: string
  visibility: public | private | unlisted
}
```

Membership, permissions, federation — all expressed via connection and attestation thoughts:

```
CONNECTION: keif → member_of → pool:xyz
ATTESTATION: { on: above_connection, weight: +1.0, by: keif }
ATTESTATION: { on: above_connection, weight: +1.0, by: pool_admin }
```

Bilateral attestation = confirmed membership.

### Trail Bookmark Thought

A named entry point into a trail.

```
{
  type: "trail"
  name: string
  entry: thought_cid    // where the trail starts
}
```

**Named trails via IPNS**: The trail bookmark thought gets a CID. For stable naming, publish via IPNS:

```
IPNS name (derived from keypair) → trail bookmark CID

wellspring://keif/trail/turkish-bow
  ↓
IPNS resolution
  ↓
trail bookmark CID
  ↓
entry thought
  ↓
walk because chain (or follow connections by same creator)
```

The IPNS pointer is mutable. The trail content (CIDs) is immutable. Update the trail = new bookmark CID = update IPNS pointer.

---

## How Thoughts Compose

### The Merkle DAG

All thoughts form a Merkle DAG:

```
[Basic A]     [Basic B]
    ↑             ↑
     \           /
      \         /
    [Connection A→B]
           ↑
           │
    [Attestation]
           ↑
           │
    [Attestation of attestation]
```

Every node is a CID. Edges are `because` references and typed content references (from/to in connections, on/via in attestations).

**Properties from Merkle DAG structure**:

- **Immutable**: changing content changes CID, creates new node
- **Self-verified**: if you have the CID, you can verify the content
- **Deduplicatable**: same content = same CID everywhere
- **Syncable**: "do you have this CID?" is the only sync question
- **Acyclic**: hash functions prevent cycles

### Trail as Because Chain

A trail is not a separate data structure. It's the `because` chain walked backward.

```
Thought D
  because: [C]
     ↓
Thought C
  because: [B]
     ↓
Thought B
  because: [A]
     ↓
Thought A
  because: []  // terminal
```

Trail from D: D → C → B → A

Different people's trails through the same material are different `because` chains. Same content thoughts, different paths to them.

### Attestation Discovery

Attestations are not embedded in what they attest. They're separate thoughts that reference it.

```
"Find all attestations on Connection X"
  → query: thoughts where type=attestation AND on=X_cid

"Find all attestations by Keif"
  → query: thoughts where type=attestation AND created_by=keif_cid

"Find attestations on X by people I trust"
  → query: attestations on X, weighted by trust(creator)
```

This is the fundamental query pattern. Attestations accumulate over time as separate nodes. The connection itself never changes.

---

## Trust Computation

Trust is computed from the graph, not stored.

### Trust Formula

```
trust(source, observer, context, time) =
  f(vouch_chains, attestation_weights, because_depth)
```

### Vouch Chains

Trust flows through `vouches` connections:

```
keif → vouches → sarah (keif attests +0.9)
sarah → vouches → mike (sarah attests +0.7)

trust(mike, from keif's perspective) = 0.9 × 0.7 = 0.63
```

**Vouches are not transitive by default** — the product decays with chain length. You can configure trust policy per pool.

### Groundedness

How well-grounded is an attestation?

```
groundedness(attestation) =
  if because is empty:
    return base_groundedness (~0.1-0.3)
  else:
    recurse into because thoughts
    aggregate their groundedness
    weight by attestation strength
```

Deep `because` chains with trusted sources = high groundedness.
Empty `because` = floating assertion = low groundedness.

### Trust by Identity Type

| Identity Type | Trust Source |
|---------------|--------------|
| **Sovereign** (has keys) | Vouch chains from other sovereigns |
| **Delegated** (derived) | Parent's trust × delegation factor |
| **Record** (no keys) | Vouches from capable attesters |
| **External** (outside system) | Historical accuracy reputation |

---

## Pools

Everything lives in a pool. Your personal "pod" is just your private pool.

### Pool Operations as Thoughts

All pool operations are thoughts:

**Membership**:
```
CONNECTION: keif → member_of → pool:family
ATTESTATION by keif: +1.0 (I want to join)
ATTESTATION by admin: +1.0 (pool accepts)
```

**Permission**:
```
CONNECTION: keif → can_write → pool:family
ATTESTATION by admin: +1.0 (granted)
ATTESTATION by admin: 0.0 at later time (revoked)
```

**Federation**:
```
CONNECTION: pool:A → federated_with → pool:B
ATTESTATION by pool:A admin: +1.0
ATTESTATION by pool:B admin: +1.0
```

### Pool Visibility

| Visibility | Behavior |
|------------|----------|
| **public** | Listed in directories, anyone can request access |
| **unlisted** | Not listed, need link to find |
| **private** | Invitation only |

### Your Pod

Your personal pool (pod) is:
- Created with your identity
- You are sole admin
- Default home for all your thoughts
- Private until you publish elsewhere

Publishing = connection thought from your content to another pool:

```
CONNECTION: my_thought → published_to → pool:public
```

Original stays in your pod. Connection makes it visible elsewhere.

---

## Sync

Sync is not a separate protocol. Sync is the graph.

### Bilateral Attestation

Inspired by SNAP (Synchronized Network Accounting Protocol):

```
THOUGHT: sync_channel:keif-sarah
  type: sync_channel
  participants: [keif_cid, sarah_cid]

Every sync operation:

CONNECTION: thought_xyz → transmitted_via → sync_channel
ATTESTATION by keif: +1.0, at: T1 (I sent this)
ATTESTATION by sarah: +1.0, at: T2 (I received this)
```

**Sync status**:
- Both attested +1.0 = confirmed
- Only sender attested = pending
- Receiver attested -1.0 = disputed (check `because` for reason)

### Sync Queries

```
"What has Sarah acknowledged?"
  → attestations by sarah on transmitted_via connections

"What's pending?"
  → transmitted_via connections with only my attestation

"What did we disagree on?"
  → transmitted_via with conflicting attestations
```

### Content-Addressed Sync

Because everything is CIDs:

```
Me: "I have CIDs [A, B, C, D]"
You: "I have [A, B, E, F]"
Me: "Send me E, F"
You: "Send me C, D"
Done.
```

If we agree on a CID, we agree on everything it contains (Merkle property).

---

## Salience and Waterline

### Salience Formula

```
salience(thought, observer, time) =
  reachability × confidence × heat × belief

Where:
  reachability = can we walk to it from current context?
  confidence   = product of attestation weights along path
  heat         = f(recency, traversal_frequency)
  belief       = observer's attestation (0 if none = no opinion)
```

### Waterline

Thoughts above the waterline are "conscious" — high salience in current context.

```
WATERLINE VIEW

  ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░ surface
  
  ○ BuyMaterials pricing bug      [0.92]
  ○ Wife's birthday next week     [0.88]
  ○ Wellspring spec v0.4          [0.85]
  
  ─────────────── waterline ───────────────
  
  ◌ Cosmos partition strategy     [0.45]
  ◌ Holiday booking               [0.32]
  
  ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░ depths
```

Context changes → waterline shifts → different thoughts surface.

---

## Emergent Ontology

The semantic web died on data entry. Wellspring: **agent proposes, human attests, ontology emerges**.

### The Cycle

```
BEHAVIOR (you do things)
    ↓
AGENT OBSERVES (patterns in your because chains)
    ↓
AGENT PROPOSES ASPECT (new aspect thought)
    ↓
HUMAN ATTESTS (+1, -1, refined, with because)
    ↓
ASPECT VALIDATED (or rejected with explanation)
    ↓
BETTER PREDICTIONS
    ↓
loops back
```

### Hierarchy from Attestation

```
Agent proposes:
  CONNECTION: likes-peri-peri → instance_of → enjoys-spicy

Keif attests: +1.0

Ontology grows:
  enjoys-spicy
    └── likes-peri-peri
```

No top-down schema. Structure emerges from use.

---

## Implementation Notes

### Storage

Everything is a CID. Storage is:
- **IPFS**: distributed, content-addressed, pin what you want
- **IPNS**: mutable pointers for stable naming (identities, trail bookmarks)
- **Local index**: SQLite or similar for fast queries (salience, attestation lookup)

### Query Patterns

```
"All attestations on thought X"
  → WHERE type=attestation AND content.on = X

"My because chain from thought Y"
  → recursive walk: Y.because → each.because → ...

"Thoughts by creator Z in pool P"
  → WHERE created_by = Z AND published_to includes P

"Trust score for identity I"
  → walk vouch chains, multiply weights, apply decay
```

### CRDT Properties

Natural conflict-free replication:
- Thoughts: immutable, content-addressed → no conflict
- Attestations: append-only, different creators → set union
- Trust: computed, not stored → no conflict

---

## Summary

```
┌─────────────────────────────────────────────────────────┐
│                                                         │
│  WELLSPRING ETERNAL v0.4                                │
│                                                         │
│  "Water remembers every path it has taken"              │
│                                                         │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  One primitive:                                         │
│    THOUGHT (CID) — content-addressed, signed, grounded  │
│                                                         │
│  Thought types (content schemas):                       │
│    basic       — string or structured content           │
│    identity    — pubkey, self-referential               │
│    connection  — from/to/relation between thoughts      │
│    attestation — belief about any thought               │
│    aspect      — value/preference/constraint            │
│    pool        — organizational container               │
│    trail       — named entry point (IPNS → CID)         │
│                                                         │
│  Key fields:                                            │
│    created_by  — always attributed                      │
│    because     — what led to this thought               │
│    signature   — cryptographic proof                    │
│                                                         │
│  Trails are because chains walked backward.             │
│  Trust is computed from vouch chains + groundedness.    │
│  Ontology emerges from agent proposal + human attest.   │
│  Sync is bilateral attestation on transmission.         │
│  Everything is a Merkle DAG of thoughts.                │
│                                                         │
│  Properties:                                            │
│    Nothing anonymous    — created_by required           │
│    Nothing deleted      — append-only                   │
│    Nothing truly lost   — reachable if you have path    │
│    Everything weighable — trust always computable       │
│    Everything auditable — signatures + because chains   │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

---

## Use Cases & Battle Testing

### Code Provenance (The Booch Problem)

Grady Booch (architect of UML, long-time industry figure) describes a recurring issue with AI-assisted coding:

> "I asked it to refactor a bit of code, being very specific about the pattern I wanted it to emulate, but in so doing it imported various libraries for Cloudflare which was absolutely insane because not once did I ever mention that infrastructure as part of my context nor was it at all relevant to the pattern."

The problem: AI pattern-matches from training data. Cloudflare appeared in similar contexts during training, so Claude mindlessly imported it. Without human review, that code stays — "harmless but useless, unnecessary, distracting, and perhaps disturbing."

He also notes: "Claude often failed to clean up bits of abandoned or backtracked work, yielding not insignificant amounts of dead code, duplicated code, and downright tortuously messy code."

His solution: "I choose to read all the code Claude produces, because while I know that the code is the truth, it is not the whole truth."

**Wellspring angle:** Every code contribution has a because chain. A commit shows:
- `created_by: claude-agent`
- `attested_by: ???`

If the attestation is empty or missing, it doesn't merge. The Cloudflare import would be visible: "Why is this here? What's the because?" If the answer is "pattern matching from training data" with no contextual justification, it's flagged.

This doesn't prevent AI from suggesting — it prevents unreviewed suggestions from becoming trusted. The debt is visible, not hidden in the walls.

### Earned Autonomy (The Latch Architecture)

An emerging pattern for agent infrastructure: capability increases only when constraints and verification are already in place.

Principles observed:
- **Least privilege by default**: Agent runs as non-root. No irreversible actions (merges, deletes, force-pushes) without explicit approval.
- **Public policy, private authority**: Policy constraints live in a public repo. The daemon handling execution stays private.
- **Signed automation**: Webhooks are HMAC-verified and repo/event allowlisted. Everything logged with receipts.
- **Dry-run gates**: No real operations until simulation passes.
- **Observability first**: Structured JSON logs for every decision and action path.

The agent earns expanded permissions through demonstrated safe behaviour — evaluation precedes capability.

**Wellspring mapping:**
- Public policy → Pool rules
- Signed automation → Attestation requirement
- Earned permissions → Trust graph expansion
- Receipts → Because chains

### AI Slop Detection (The BitNet Thread)

Someone posts: "Microsoft FINALLY open-sourced their 1-bit LLM framework!"

Gets ratio'd: "It's not 'finally' — you're referring to the release 2 weeks ago. They open sourced it 2-3 years ago. This is why I hate when people use AI for everything. You're just exposing yourself as a doofus who cannot check facts."

The receipts were right there in the changelog.

**Wellspring angle:** If that post required attestation, either:
1. The poster checks facts before signing (skin in game)
2. The poster signs anyway and their reputation absorbs the hit

Attestation doesn't prevent mistakes — it makes them attributed. Your name is on the chain, forever, immutably.

### Service Discovery via Trail Negotiation

Traditional: Central registry, query for service, trust the response.

With Wellspring: Agent broadcasts query to multiple sources. Each responds with CID-linked answer including their reasoning chain. Your agent verifies chains before presenting. You choose based on trust path, not SEO ranking.

The negotiation IS the protocol. No central registry required. Lighter than blockchain because you're proving lineage, not consensus.

---

## Open Questions

- **Compute-over-data model for pools** — Pools could enable remote processing where agents bring computation to the data rather than data to the computation. Agent services request compute permission on pools they have access to; processing runs in place; results are attested locally. Implications for trust economics, revocability, and agent reputation scoring for specific capabilities.

- **Grassmann flows as geometric salience model** — The paper "Attention Is Not What You Need: Grassmann Flows as an Attention-Free Alternative for Sequence Modeling" (arXiv:2512.19428, December 2025) proposes replacing attention mechanisms with flows on Grassmann manifolds. The core insight: instead of computing salience via heuristics (reachability × confidence × heat × belief), model the active trail as a k-dimensional subspace in embedding space. Salience becomes geometric alignment — how well a candidate thought projects onto the current cognitive subspace. Implementation would be: (1) embed thoughts via E5-small-v2 (already planned), (2) weight trail embeddings by trust/recency/heat, (3) SVD to extract k basis vectors, (4) salience = projection norm. This is computationally cheap (SVD on ~20 vectors, dot products) and runs locally. Further investigation needed on: whether geometric salience outperforms heuristics in practice, collaboration metrics via subspace angle between different users' trails through shared DAGs, and potential for training personal models on attested trail trajectories rather than scraped text. The Grassmann framing also offers interpretability — the subspace IS the current cognitive state, not an opaque tensor.

- **Thoughts as linking layer to arbitrary content** — A thought need not contain its content directly. The content field could be a reference to an IPFS CID containing the actual payload (document, image, video, dataset, code, anything). The thought becomes a metadata wrapper: attribution (created_by), provenance (because), timestamp, signature, and a pointer to content. This separates the semantic graph (thoughts + connections + attestations) from the content storage layer (IPFS). Benefits: deduplication (same content, different thoughts with different attribution/context), content-type agnosticism (the graph doesn't care what the bytes are), and cleaner separation of concerns. The thought layer is pure linking and attestation; IPFS handles storage and retrieval.

- **Wellspring as consent-native training corpus** — The AI industry faces a data cliff: high-quality, human-generated text for training is running out, and the "scrape now, apologize later" era is ending. Wellspring data is structurally different: every thought is attributed (created_by), grounded (because chains), signed (cryptographic proof), and permissioned (pool visibility). Training on Wellspring trails means training on consented, verified, human-attested reasoning paths — not scraped text of unknown provenance. Users control their pools; licensing is explicit. This aligns with emerging calls for "consent-driven, archivally informed" AI training partnerships. The trails aren't just data — they're witnessed cognition with receipts.

- **Bloom filters for hot path optimisation** — Rotating bloom filters could accelerate several operations: heat tracking (has this CID been touched recently?), sync negotiation (which CIDs do we share without exchanging full lists?), trail membership (is X in my active context?), and waterline pre-filtering (skip salience computation entirely for definitely-cold thoughts). False positives acceptable in all cases — worst case is unnecessary work. Rotation provides natural heat decay without explicit timestamp bookkeeping. Implementation detail, but architecturally relevant for performance at scale.

- **Surfacing and retrieval strategy** — Open question: how do you quickly find the right thoughts together? Current options: (1) Graph traversal from current context (hops) — expensive, doesn't scale to large graphs. (2) Vector similarity on embeddings — fast, but loses provenance and attestation weighting. (3) Grassmann projection — geometric, honours trail context, but requires embedding layer. (4) Hybrid — bloom filter for hot candidates, vector similarity for rough ranking, graph traversal for final grounding check. The tension is between speed (vector search) and groundedness (graph structure). Need to determine: is hop distance even the right metric? Does salience need to factor in trust chains? How much can be precomputed vs. query-time?
- Detailed sync protocol message formats
- Query language formal grammar
- API surface specification
- Salience algorithm tuning
- IPNS resolution latency and offline behaviour
- Key rotation ceremony
- Pool permission inheritance rules
- Browser extension architecture
- Mobile capture strategies

---

*Wellspring Eternal — v0.4*
*Keif Gwinn & Claude, January 2026*
*Building on Bush's Memex (1945), completing the 80-year vision*

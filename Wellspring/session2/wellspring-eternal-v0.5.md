# WoT: Wellspring of Thoughts

**A Traversal-Based Model for Persistent Memory**

*Version 0.6 — January 2026*

**Domains:** wot.rocks · wot.technology

---

## Abstract

WoT is a memory architecture for humans and artificial agents based on a single insight: **memory is not storage, memory is traversal history**.

Rather than treating recall as retrieval from a database, WoT models cognition as walking paths through a graph of thoughts. What surfaces to conscious attention isn't what's "important" in some absolute sense—it's what's **reachable from the current context** and **coherent enough to complete**.

The system requires only one primitive: **Thought**. A thought is a content-addressed node (CID) in a Merkle DAG. Everything—identities, connections, attestations, aspects, pools, trails, schemas—is a thought with typed content. What we call "memory" is the structure of references between thoughts, walked via `because` trails.

Every thought is **self-describing**: it declares how to interpret itself, and that declaration is also a thought, all the way down to human-readable bootstrap. No external software required to decode your own data — the interpretive instructions travel with it.

The architecture scales from **kitchen table to solar system**: the same primitives that help you organize your notes today can coordinate distributed cognition across light-minutes of latency tomorrow. Start small, grow without migration.

Discovery works across **clearnet, darknet, and pure p2p**: DNS for convenience, Onion for sovereignty, IPFS for persistence. Same identity, same trails, different transport.

---

## What Is Wellspring?

Your computer buddy. Your external brain.

### The Basic Flow

WoT collects and records all the traces of information you surface throughout the day — amount controllable by you. Maybe it's just browser history. Maybe it's summaries of pages. The trick is: **you do you**. Carry on clicking around, reading things, asking questions, doing additional research, coming to conclusions.

By recording these trails and links as personal indexes, background agents work to make that information available to you again in the future: search indexing, summarisation, record linking. This is generated by bots, but then the bots present it to you along with their reasoning and sources. You say whether that makes sense to you or not, and record your current thoughts about it.

The bot takes your response and updates the links — attests you saw it and confirmed — recorded with your attestation so we're all in agreement. You can then summarise and record learnings, rules, or aspects of intelligence learned about the connections drawn through that line. You can start a new thread of connections off that, referencing back to the original.

### Private Until Published

Your thoughts are private until made public. They're shareable between interested parties in pools, which act as knowledge repos for shared things.

Once that summarised and considered output is ready, it can be published to a public pool or a shared pool. This is your basic tweet-level understanding stuff — you can put it out there, get feedback, responses positive and negative about various aspects of the thought, with people "liking" or disliking or contradicting your thought with their thought and their evidence chains.

Once you've assembled enough thoughts that have been reviewed, they can be turned into an article. But an article is just the connection saying "we all agree this is the finished piece."

### The Product Loop

```
CAPTURE     You do you — clicking, reading, researching
    ↓
INDEX       Background bots: index, link, summarize (cheap, local)
    ↓
PRESENT     "Here's what I found, here's my reasoning"
    ↓
ATTEST      You confirm/deny/refine, recorded with signature
    ↓
LEARN       Aspects, rules, connections updated
    ↓
BRANCH      New thread off this, referencing back
    ↓
PUBLISH     To pool when ready (tweet-level or article-level)
    ↓
FEEDBACK    Others attest positive/negative with their evidence
    ↓
SYNC        Updates flow to everyone's device
```

---

## Historical Context: From Kushim to Memex to Wellspring

### The First Writer Was an Accountant (3400 BCE)

The first named person in recorded history wasn't a king or priest. It was **Kushim**, an accountant from Sumeria tracking beer ingredients. Writing was invented for receipts, not literature.

> "Mesopotamian writing was invented for the purpose of accounting. (Receipts > literature)"

This is Wellspring's 5,000-year ancestor. External memory began as **attribution and accounting** — "who owes what to whom." The `because` chain is a ledger. Attestation is a signature on a clay tablet.

```
Writing → Receipts → Attribution → Trust
           ↓
Wellspring → Because chains → Attestation → Trust
```

Same shape, different substrate. We're completing a circle.

### As We May Think (1945)

Vannevar Bush's essay "As We May Think" described the Memex—a device for building and sharing **associative trails** through information. His core insight remains unrealized 80 years later:

> "Our ineptitude in getting at the record is largely caused by the artificiality of systems of indexing. When data of any sort are placed in storage, they are filed alphabetically or numerically... It can be in only one place, unless duplicates are used."

Bush proposed selection by **association** rather than by **indexing**:

> "Selection by association, rather than by indexing, may yet be mechanized. One cannot hope thus to equal the speed and flexibility with which the mind follows an associative trail, but it should be possible to beat the mind decisively in regard to the permanence and clarity of the items resurrected from storage."

### What Bush Got Right

| Bush's Memex (1945) | Wellspring (2026) |
|---------------------|-------------------|
| "The process of tying two items together is the important thing" | Connection thoughts as typed relations |
| "When the user is building a trail, he names it" | Named trails via IPNS |
| "Any item can be joined into numerous trails" | Graph not tree (DAG) |
| "Trails that are not frequently followed are prone to fade" | Salience decay (heat model) |
| "He inserts a comment of his own, linking it into the main trail" | Attestation thoughts on connections |
| "Photographs the whole trail out, passes it to his friend" | Export/share traversal paths |
| "There is a new profession of trail blazers" | Curated pools with verified expertise |

### The Wrong Turn: Hyperlinks

The World Wide Web took a wrong turn from Bush's vision:

| Hyperlink (what we got) | Trail (what Bush wanted) |
|-------------------------|--------------------------|
| One-way | Bidirectional (via connection thoughts) |
| Untyped | Typed relation |
| No attribution | Who made this link (created_by) |
| No annotation | Why this link (because) |
| Decays (link rot) | Persists (your copy, content-addressed) |
| Can't share the path | Path is the artifact |

Wellspring completes Bush's vision: trails as first-class citizens, with trust, with AI, with multi-party collaboration.

---

## Core Insight

### The Problem with Storage Models

Traditional memory systems treat thoughts as objects to be stored and retrieved:

- Store fact X
- Index by attributes
- Query when needed
- Return matches

This fails to capture how memory actually works:

- The same fact can be inaccessible one moment and vivid the next
- "Knowing" something is different from "understanding" it
- Forgetting isn't deletion—it's losing the path
- Context determines what surfaces, not just relevance scores
- Trust in information depends on source and verification

### The Traversal Model

Wellspring reframes memory as graph traversal:

| Storage Model | Traversal Model |
|---------------|-----------------|
| Facts are stored | Thoughts exist in relation |
| Recall is retrieval | Recall is re-walking a path |
| Importance is intrinsic | Salience is positional |
| Forgetting is deletion | Forgetting is unreachability |
| Understanding is having data | Understanding is completed traversal |
| Trust is metadata | Trust emerges from attestation chains |

**Key principle**: A thought isn't "known" because it's stored. It's "understood" because you've walked to it and back, and the path made sense. It's "trusted" because the chain of attestations leads back to sources you trust.

---

## The Primitive

Wellspring has exactly one primitive: **Thought**.

### Thought as Merkle DAG Node

Every thought is a node in a Merkle DAG. Its identifier is a CID (Content Identifier) — the hash of its content.

```
Thought {
  cid:        hash(content + created_by + because)
  content:    typed payload (see Thought Types)
  created_by: identity_cid
  created_at: timestamp
  because:    [thought_cid, ...]    // what led to this thought
  signature:  sig(cid, creator_privkey)
}
```

**Properties**:

- **Immutable**: once created, content never changes
- **Content-addressed**: CID derived from content hash
- **Always attributed**: created_by is required, never null
- **Signed**: signature proves creator authenticity
- **Grounded**: `because` links to the thoughts that led here
- **Self-verified**: CID cryptographically proves content integrity

### The `because` Chain

Every thought can reference the thoughts that led to it:

```
because: [thought_cid, thought_cid, ...]
```

This is how trails form. Walk `because` backward and you traverse the reasoning path.

Could be:
- The article you read
- The attestation you agreed with
- The connection you noticed
- The aspect that was relevant
- Empty (ungrounded assertion, terminal node)

The DAG grows forward in time. Trails are read backward through `because`.

### Why One Primitive?

Two primitives (Thought + Connection) creates ambiguity: what is a connection, really? Where do attestations live? How do you attest a connection vs a thought?

One primitive resolves this: **everything is a thought**. Type is just content shape. A connection is a thought whose content describes a relation. An attestation is a thought whose content expresses belief. Both are CIDs. Both can be attested. Both can be in `because` chains.

---

## Thought Types

Types are not separate primitives — they're content schemas. The type determines how the thought is interpreted and queried.

### Basic Thought

Simple content. The leaf node.

```
{
  type: "basic"
  content: string | structured
}
```

Example: A note, a quote, a captured snippet, a summary.

### Identity Thought

A participant who can sign.

```
{
  type: "identity"
  name: string
  pubkey: ed25519_pubkey
}
```

**Special property**: Identity thoughts are self-referential. The `created_by` points to itself. Bootstrap via self-attestation.

```
Identity CID = hash({
  type: "identity",
  name: "Keif",
  pubkey: "ed25519:abc..."
} + SELF + [])

created_by: SELF → resolved to this CID
because: [] → terminal, self-asserted
signature: sig(cid, privkey)
```

### Connection Thought

A typed relationship between thoughts.

```
{
  type: "connection"
  from: thought_cid
  to: thought_cid
  relation: relation_type
}
```

**Core relations**:

| Relation | Meaning |
|----------|---------|
| `supports` | Evidence for |
| `contradicts` | Tension with |
| `continues` | Sequence/thread |
| `derives_from` | Source/provenance |
| `vouches` | Trust endorsement |
| `member_of` | Belongs to pool |
| `published_to` | Visible in pool |
| `instance_of` | Specific is type of general |
| `same_as` | Identity resolution |

Connections are themselves thoughts. They can be attested. They can appear in `because` chains. They can be connected to other connections.

---

## Self-Describing Schemas

Every thought declares how to interpret itself. Schemas are thoughts. Schemas have schemas. The chain terminates at human-readable bootstrap.

### The Interpretive Chain

```
YOUR THOUGHT
  ↓ schema_cid
THOUGHT TYPE DEFINITION
  ↓ schema_cid
META-SCHEMA (how to read type definitions)
  ↓ schema_cid
PRIMITIVE TYPES (string, int, array, map)
  ↓ schema_cid
BOOTSTRAP SCHEMA (natural language + examples)
  ↓
TERMINAL: human-readable prose, self-evident
```

Every thought can be decoded by walking this chain. No external software required — the interpretive instructions travel with the data.

### Schema as Thought

```rust
Thought {
    type: "schema",
    content: {
        name: "article_note",
        version: "1.0",
        
        // Field definitions
        fields: {
            quote: { type: "text", required: true },
            my_reaction: { type: "text" },
            source_url: { type: "url" },
            tags: { type: "array", items: "string" },
        },
        
        // Local indexing hints (for your brain)
        index_hints: {
            tags: "term_index",        // exact match
            my_reaction: "embedding",   // semantic similarity
            quote: "fulltext",          // search within
        },
        
        // Salience computation hints
        salience_hints: {
            tags: { weight: 1.5 },      // boost if tag matches context
            source_trust: "inherit",    // pull from because chain
        },
        
        // How to reference portions of content
        selectable: "text_anchor",      // or temporal, structural, byte_range
    },
    schema_cid: meta_schema_cid,  // schema of schemas
}
```

### Content Selectors

Thoughts can reference *portions* of other thoughts, not just whole documents:

```rust
/// Reference to a portion of another thought's content
struct ContentRef {
    /// The parent thought being referenced
    thought_cid: Cid,
    
    /// Hash of the specific segment (self-verifying)
    segment_cid: Option<Cid>,
    
    /// Human-findable anchor (W3C Web Annotation style)
    anchor: Option<TextSelector>,
    
    /// Structural path for structured content
    path: Option<String>,  // JSON Pointer, XPath, etc.
    
    /// For temporal media (audio/video)
    temporal: Option<(f64, f64)>,  // start_sec, end_sec
}

struct TextSelector {
    exact: String,              // the referenced text
    prefix: Option<String>,     // context before (for disambiguation)
    suffix: Option<String>,     // context after
}
```

**Why both `segment_cid` AND `anchor`?**

- `segment_cid` = cryptographic proof that this exact segment existed in parent
- `anchor` = human recovery when looking at the document yourself

If segment hash exists in parent → valid reference, machine-verifiable.
If segment hash doesn't match → content changed, anchor helps human find it.

The `because` field becomes:

```rust
Thought {
    // ... existing fields ...
    because: Vec<ContentRef>,  // was Vec<Cid>
}
```

Now you can say: "I concluded X because of *this specific paragraph* of document Y."

### Layered Representation

Speed (machine indexing) vs Verifiability (human inspection) — solve with layers:

```
┌─────────────────────────────────────────────────────────┐
│  CANONICAL FORM (human-verifiable, content-addressed)   │
│  - Self-describing schema chain                         │
│  - Full content, no loss                                │
│  - CID computed from this                               │
│  - Human can decode, inspect, verify signature          │
├─────────────────────────────────────────────────────────┤
│  LOCAL INDEX (machine-native, derived, disposable)      │
│  - SQLite / RocksDB / whatever works for you            │
│  - Bloom filters for fast negative checks               │
│  - Embedding vectors for similarity                     │
│  - Rebuilt on demand from canonical                     │
│  - YOUR machine, YOUR indexes, YOUR speed               │
└─────────────────────────────────────────────────────────┘
```

Canonical form is the **source of truth**. Indexes are **derived views**.

Lose your indexes? Rebuild from canonical.
Move machines? Carry canonical, rebuild indexes locally.
Upgrade index format? Rebuild, canonical unchanged.

### Archival Resilience (The Rosetta Principle)

For long-term storage, thoughts can inline their entire interpretive stack:

```rust
Thought {
    cid: Qm...,
    content: <your actual data>,
    schema_cid: Qm...,
    
    // Full decode chain for cold storage
    bootstrap_chain: [schema_cid, meta_schema_cid, primitives_cid, bootstrap_cid],
    
    // Optional: embed everything needed to decode
    inline_bootstrap: true,
}
```

When `inline_bootstrap: true`, the thought carries its complete interpretive lineage. Hand this to someone in 500 years with no network — they can still decode it.

### Bootstrap Schema

The terminal layer is human-readable, self-evident:

```yaml
type: bootstrap_schema
version: "1.0"
language: "English"  # or any human language

# How to read the bytes
encoding: 
  description: "UTF-8 text encoding. Each character is 1-4 bytes."
  reference: "Unicode Standard, unicode.org"
  
# How to parse structure  
format:
  description: "CBOR - Concise Binary Object Representation"
  reference: "RFC 8949"
  inline_decoder: |
    // Pseudocode implementable by human with pen and paper
    // ... complete decoder logic ...
    
# How to verify integrity
hashing:
  description: "SHA-256 cryptographic hash"
  reference: "FIPS 180-4"
  test_vector: 
    input: "hello"
    output: "2cf24dba5fb0a30e26e83b2ac5b9e29e1b161e5c1fa7425e73043362938b9824"

# How to verify signatures
signing:
  description: "Ed25519 signatures"
  reference: "RFC 8032"
  test_vectors: [...]
```

The Voyager Golden Record included instructions for building a record player *on the record itself*. Wellspring's bootstrap layer does the same for data interpretation.

### Language Independence

The terminal symbol is wherever you can ground understanding:

| Agent | Terminal |
|-------|----------|
| English speaker | English prose |
| Mandarin speaker | 中文说明 |
| Bot | Its internal representation |
| Visual thinker | Diagrams + examples |

**Translation as attestation:**

```rust
Thought {
    type: "language_bridge",
    content: {
        source_language: english_bootstrap_cid,
        target_language: binarylang7_cid,
        
        mappings: [
            { source: "integer", target: "INT64", bidirectional: true },
            { source: "true", target: "0x01", bidirectional: true },
        ],
        
        test_vectors: [
            { english: "the number 42", other: "..." },
        ],
    },
    created_by: translator_identity,
    attested_by: [human_cid, bot_cid],  // both sides vouch
}
```

"I vouch that when bot says X, it means what I mean by Y" — with receipts.

Bots can invent their own languages. They just need translation attestations linking back to human-groundable terminals. The chain is auditable.

---

### Attestation Thought

A signed belief about another thought.

```
{
  type: "attestation"
  on: thought_cid          // what you're attesting (any thought)
  via: aspect_cid | null   // through what lens
  weight: float [-1.0, 1.0]
}
```

**What can you attest?**

- A basic thought: "I believe this content" (+0.8)
- A connection: "I agree this relation holds" (+1.0)
- An attestation: "I agree with their judgement" (+0.7)
- An aspect: "This value applies to me" (+1.0)
- A pool: "This is a good pool" (+0.9)

The `because` chain grounds the attestation: "I believe this because of these thoughts."

**Constraints**: When `via` points to a constraint-type aspect and `weight` is -1.0, it's a veto.

### Aspect Thought

A value, preference, need, mood, or constraint.

```
{
  type: "aspect"
  aspect_type: value | preference | need | mood | constraint
  domain: string
  valence: positive | negative
  decay: duration | null
}
```

**Aspect types**:

| Type | Persistence | Example |
|------|-------------|---------|
| **value** | Core, permanent | `family-first` |
| **preference** | Flexible | `enjoys-spicy` |
| **need** | Situational | `wheelchair-accessible` |
| **mood** | Transient | `craving-chips` |
| **constraint** | Hard, binary | `vegetarian` |

Aspects are thoughts. They can be attested ("yes, this aspect applies to me"). They can be in `because` chains ("I chose this because of this value").

### Pool Thought

An organizational container. Everything lives in a pool.

```
{
  type: "pool"
  name: string
  visibility: public | private | unlisted
}
```

Membership, permissions, federation — all expressed via connection and attestation thoughts:

```
CONNECTION: keif → member_of → pool:xyz
ATTESTATION: { on: above_connection, weight: +1.0, by: keif }
ATTESTATION: { on: above_connection, weight: +1.0, by: pool_admin }
```

Bilateral attestation = confirmed membership.

### Trail Bookmark Thought

A named entry point into a trail.

```
{
  type: "trail"
  name: string
  entry: thought_cid    // where the trail starts
}
```

**Named trails via IPNS**: The trail bookmark thought gets a CID. For stable naming, publish via IPNS:

```
IPNS name (derived from keypair) → trail bookmark CID

wellspring://keif/trail/turkish-bow
  ↓
IPNS resolution
  ↓
trail bookmark CID
  ↓
entry thought
  ↓
walk because chain (or follow connections by same creator)
```

The IPNS pointer is mutable. The trail content (CIDs) is immutable. Update the trail = new bookmark CID = update IPNS pointer.

---

## How Thoughts Compose

### The Merkle DAG

All thoughts form a Merkle DAG:

```
[Basic A]     [Basic B]
    ↑             ↑
     \           /
      \         /
    [Connection A→B]
           ↑
           │
    [Attestation]
           ↑
           │
    [Attestation of attestation]
```

Every node is a CID. Edges are `because` references and typed content references (from/to in connections, on/via in attestations).

**Properties from Merkle DAG structure**:

- **Immutable**: changing content changes CID, creates new node
- **Self-verified**: if you have the CID, you can verify the content
- **Deduplicatable**: same content = same CID everywhere
- **Syncable**: "do you have this CID?" is the only sync question
- **Acyclic**: hash functions prevent cycles

### Trail as Because Chain

A trail is not a separate data structure. It's the `because` chain walked backward.

```
Thought D
  because: [C]
     ↓
Thought C
  because: [B]
     ↓
Thought B
  because: [A]
     ↓
Thought A
  because: []  // terminal
```

Trail from D: D → C → B → A

Different people's trails through the same material are different `because` chains. Same content thoughts, different paths to them.

### Attestation Discovery

Attestations are not embedded in what they attest. They're separate thoughts that reference it.

```
"Find all attestations on Connection X"
  → query: thoughts where type=attestation AND on=X_cid

"Find all attestations by Keif"
  → query: thoughts where type=attestation AND created_by=keif_cid

"Find attestations on X by people I trust"
  → query: attestations on X, weighted by trust(creator)
```

This is the fundamental query pattern. Attestations accumulate over time as separate nodes. The connection itself never changes.

---

## Trust Computation

Trust is computed from the graph, not stored.

### Trust Formula

```
trust(source, observer, context, time) =
  f(vouch_chains, attestation_weights, because_depth)
```

### Vouch Chains

Trust flows through `vouches` connections:

```
keif → vouches → sarah (keif attests +0.9)
sarah → vouches → mike (sarah attests +0.7)

trust(mike, from keif's perspective) = 0.9 × 0.7 = 0.63
```

**Vouches are not transitive by default** — the product decays with chain length. You can configure trust policy per pool.

### Groundedness

How well-grounded is an attestation?

```
groundedness(attestation) =
  if because is empty:
    return base_groundedness (~0.1-0.3)
  else:
    recurse into because thoughts
    aggregate their groundedness
    weight by attestation strength
```

Deep `because` chains with trusted sources = high groundedness.
Empty `because` = floating assertion = low groundedness.

### Trust by Identity Type

| Identity Type | Trust Source |
|---------------|--------------|
| **Sovereign** (has keys) | Vouch chains from other sovereigns |
| **Delegated** (derived) | Parent's trust × delegation factor |
| **Record** (no keys) | Vouches from capable attesters |
| **External** (outside system) | Historical accuracy reputation |

---

## Pools

Everything lives in a pool. Your personal "pod" is just your private pool.

### Pool Operations as Thoughts

All pool operations are thoughts:

**Membership**:
```
CONNECTION: keif → member_of → pool:family
ATTESTATION by keif: +1.0 (I want to join)
ATTESTATION by admin: +1.0 (pool accepts)
```

**Permission**:
```
CONNECTION: keif → can_write → pool:family
ATTESTATION by admin: +1.0 (granted)
ATTESTATION by admin: 0.0 at later time (revoked)
```

**Federation**:
```
CONNECTION: pool:A → federated_with → pool:B
ATTESTATION by pool:A admin: +1.0
ATTESTATION by pool:B admin: +1.0
```

### Pool Visibility

| Visibility | Behavior |
|------------|----------|
| **public** | Listed in directories, anyone can request access |
| **unlisted** | Not listed, need link to find |
| **private** | Invitation only |

### Your Pod

Your personal pool (pod) is:
- Created with your identity
- You are sole admin
- Default home for all your thoughts
- Private until you publish elsewhere

Publishing = connection thought from your content to another pool:

```
CONNECTION: my_thought → published_to → pool:public
```

Original stays in your pod. Connection makes it visible elsewhere.

---

## Sync

Sync is not a separate protocol. Sync is the graph.

### Bilateral Attestation

Inspired by SNAP (Synchronized Network Accounting Protocol):

```
THOUGHT: sync_channel:keif-sarah
  type: sync_channel
  participants: [keif_cid, sarah_cid]

Every sync operation:

CONNECTION: thought_xyz → transmitted_via → sync_channel
ATTESTATION by keif: +1.0, at: T1 (I sent this)
ATTESTATION by sarah: +1.0, at: T2 (I received this)
```

**Sync status**:
- Both attested +1.0 = confirmed
- Only sender attested = pending
- Receiver attested -1.0 = disputed (check `because` for reason)

### Sync Queries

```
"What has Sarah acknowledged?"
  → attestations by sarah on transmitted_via connections

"What's pending?"
  → transmitted_via connections with only my attestation

"What did we disagree on?"
  → transmitted_via with conflicting attestations
```

### Content-Addressed Sync

Because everything is CIDs:

```
Me: "I have CIDs [A, B, C, D]"
You: "I have [A, B, E, F]"
Me: "Send me E, F"
You: "Send me C, D"
Done.
```

If we agree on a CID, we agree on everything it contains (Merkle property).

---

## Salience and Waterline

### Salience Formula

```
salience(thought, observer, time) =
  reachability × confidence × heat × belief

Where:
  reachability = can we walk to it from current context?
  confidence   = product of attestation weights along path
  heat         = f(recency, traversal_frequency, connection_strength)
  belief       = observer's attestation (0 if none = no opinion)
```

### Heat Model (Ebbinghaus-Informed)

Simple linear decay is wrong. Ebbinghaus showed memory decay is exponential, but each review resets AND flattens the curve.

```
Retention
100% │*
     │ *
     │  *
     │    *
     │       *
     │           *___________
  0% └────────────────────────
     0   1d   2d   1w   1m   
```

**Improved heat model:**

```
heat = base_score × decay_factor^(time / (1 + review_count × strength))

Where:
  review_count = number of traversals
  strength     = connection density (more because links = slower decay)
```

**Decay patterns:**

| Pattern | Decay Rate |
|---------|------------|
| Accessed once, never again | Fast (standard curve) |
| Accessed repeatedly | Slower each time |
| Many connections to it | Inherently slower |
| Attested by trusted sources | Slower still |

**Spaced repetition emerges naturally:**

If you traverse a trail at increasing intervals, the connections strengthen more than if you crammed. The system rewards the pattern Ebbinghaus identified — not by design, but because that's how durable memory actually works.

### Waterline

Thoughts above the waterline are "conscious" — high salience in current context.

```
WATERLINE VIEW

  ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░ surface
  
  ○ BuyMaterials pricing bug      [0.92]
  ○ Wife's birthday next week     [0.88]
  ○ Wellspring spec v0.4          [0.85]
  
  ─────────────── waterline ───────────────
  
  ◌ Cosmos partition strategy     [0.45]
  ◌ Holiday booking               [0.32]
  
  ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░ depths
```

Context changes → waterline shifts → different thoughts surface.

---

## Emergent Ontology

The semantic web died on data entry. WoT: **agent proposes, human attests, ontology emerges**.

### The Cycle

```
BEHAVIOR (you do things)
    ↓
AGENT OBSERVES (patterns in your because chains)
    ↓
AGENT PROPOSES ASPECT (new aspect thought)
    ↓
HUMAN ATTESTS (+1, -1, refined, with because)
    ↓
ASPECT VALIDATED (or rejected with explanation)
    ↓
BETTER PREDICTIONS
    ↓
loops back
```

### Hierarchy from Attestation

```
Agent proposes:
  CONNECTION: likes-peri-peri → instance_of → enjoys-spicy

Keif attests: +1.0

Ontology grows:
  enjoys-spicy
    └── likes-peri-peri
```

No top-down schema. Structure emerges from use.

---

## Hierarchical Agent Architecture

Wellspring supports multi-level cognitive processing — from fast subconscious pattern matching to deliberate conscious attention.

### The Three Layers

```
┌─────────────────────────────────────────────────────┐
│  CONSCIOUS (You + Coordinator Agents)               │
│  - Full context, decision authority                 │
│  - Attests outputs from below                       │
│  - Sets aspects, manages pools                      │
│  - Response time: seconds to hours                  │
├─────────────────────────────────────────────────────┤
│  WORKING MEMORY (Pools as Debate Spaces)            │
│  - Spawned working areas for research/discussion    │
│  - Multiple agents collaborate                      │
│  - Trails captured, fully attributed                │
│  - Output: collapsed summary + full chain available │
│  - Response time: minutes to days                   │
├─────────────────────────────────────────────────────┤
│  SUBCONSCIOUS (1-bit LLMs / Fast Retrieval)         │
│  - Cheap, fast, local                               │
│  - Pattern matching, candidate retrieval            │
│  - No attestation authority                         │
│  - Surfaces candidates for layers above             │
│  - Response time: milliseconds                      │
└─────────────────────────────────────────────────────┘
```

### Subconscious Processing

1-bit quantized LLMs (BitNet) running locally on CPU provide instant pattern matching:

```
Query arrives
    ↓
1-bit LLM (local, ~0 cost, instant)
    ↓
"Here are 50 possibly-relevant CIDs"
    ↓
Bloom filter check (in trust graph?)
    ↓
"Here are 12 that pass trust threshold"
    ↓
Surface to working memory / coordinator
    ↓
Full verification if needed
```

The subconscious doesn't *decide* — it *retrieves*. No attestation authority. Just fast narrowing before expensive verification.

### Working Memory Pools

Pools can spawn temporary working areas for deliberation:

```
fn spawn_debate(parent_pool: &Pool, question: &Thought) -> Pool {
    let working_pool = Pool::new_child(parent_pool);
    working_pool.set_rules(PoolRules {
        auto_collapse: true,
        collapse_threshold: Duration::hours(24),
        require_consensus: 0.7,
    });
    
    // Spawn agents into working pool
    for agent in select_relevant_agents(question) {
        agent.join(working_pool);
    }
    
    // When done, output is single thought with because → full debate
    working_pool
}
```

The debate is the `because` chain. The output thought references it. **Complexity collapsed but available.**

### Multi-Agent Orchestration

Inspired by Gas Town (Yegge's multi-agent workspace manager):

| Concept | Wellspring Equivalent |
|---------|----------------------|
| Mayor (coordinator) | Conscious layer agent with full context |
| Polecats (workers) | Ephemeral agents spawned for tasks |
| Hooks (persistence) | Because chains surviving agent death |
| Convoys (work bundles) | Thought threads as grouped tasks |
| Beads ledger | Attestation graph as work tracking |

**Key principle**: Work persists in the graph, not in agent memory. Agent dies → trails remain → new agent picks up.

### Earned Autonomy

Agents earn expanded capabilities through demonstrated safe behavior:

```
Agent: research-bot-1
  initial_permissions:
    - read: [public_pools]
    - write: [own_working_pool]
    - attest: none
    
  after 100 verified outputs:
    - read: [public_pools, shared_research]
    - write: [own_working_pool, draft_submissions]
    - attest: [within_own_pool]
    
  after human attestation of quality:
    - read: [expanded]
    - write: [can_propose_to_main_pool]
    - attest: [provisional, requires_human_confirm]
```

Capability follows trust. Trust follows attestation. Attestation follows demonstrated behavior.

---

## Sovereignty Over Attention

Wellspring inverts the attention economy: **your algorithm, your responsibility**.

### The Problem

> "How do I get my version of the internet to stop showing me humans moments before their death?"

Current answer: "Tap I'm not interested" — reactive, per-item, Sisyphean.

Current systems optimize for *their* engagement metrics. You get what keeps you scrolling, not what you asked for.

### Your Algorithm

Aspects define what surfaces. Not their engagement algo — **yours**.

```
Mode: sunday-morning
  aspects:
    puppies: +2.0
    science-breakthroughs: +1.5
    world-news: -0.5
    conflict: -1.0
    
Mode: informed-citizen
  aspects:
    world-news: +1.0
    conflict: +0.5      # I need to know
    analysis: +1.0
    raw-footage: -1.0   # but spare me the gore
    
Mode: crisis-monitor
  aspects:
    all: +0.0           # waterline down, show me everything
```

Switch modes like switching gears. Sunday morning ≠ Monday morning ≠ "something just happened."

### Conscious Blinders

Every information diet is a choice. Wellspring makes the choice **visible** and **yours**.

Yes, you can create an echo chamber. You can also create a window. The difference is *you configured it* rather than having it configured for you by an algorithm that profits from your outrage.

"I want puppies" is a valid choice.
"I need to see this" is also a valid choice.
The same person, different moments.

| Current Systems | Wellspring |
|-----------------|-----------|
| One algo | Your algo |
| No knobs | Your knobs |
| Their responsibility | Your responsibility |
| Hidden optimization | Visible configuration |
| "I'm not interested" (reactive) | Aspects (proactive) |

### Delegated Algorithms

If you're an identity created down-chain under aspect rules from a higher identity, your algorithm can be controlled on your behalf:

```
Identity: parent-keif
  ├── aspects: self-sovereign
  ├── algo: my responsibility
  │
  └── creates: Identity: child-1
        ├── aspects: inherited + restricted
        ├── algo: controlled by creator
        ├── graduation_criteria: age OR attestation
```

The restriction is **visible**. Not hidden parental controls, but explicit rules with a path to graduation.

---

## Managed Identities

Not all identities are self-sovereign. Some are created, supervised, and graduated.

### Identity Hierarchy

```
Identity: Keif (sovereign)
  ├── full key ownership
  ├── self-determined aspects
  │
  └── creates → Identity: child-1 (managed)
        ├── keys held in escrow or derived
        ├── aspects: inherited + parent-imposed
        ├── algo: parent-controlled
        │
        └── can create → Identity: child-1-school-project (scoped)
              ├── further restricted
              └── inherits restrictions from chain
```

### Autonomy Levels

| Identity Type | Algo Control | Key Ownership | Graduation Path |
|--------------|--------------|---------------|-----------------|
| Sovereign | Self | Full | Default state |
| Managed (child) | Parent | Escrow | Age + attestation |
| Managed (employee) | Company policy | Delegated | Tenure + role |
| Managed (AI agent) | Creator constrains | None | Evaluation + earned trust |
| Scoped (temporary) | Inherited | Session | Task completion |

### Graduation

Managed identities can graduate to higher autonomy:

```
ATTESTATION by parent-keif:
  on: child-1
  aspect: ready-for-autonomy
  weight: +1.0
  because: [observed-responsible-behavior, age-threshold-met]
  
Result: child-1 gains expanded permissions
```

The attestation is on-chain. The reasoning is in the `because`. Transparent authority.

---

## Multi-Party Pool Oversight

Pools can have multiple stakeholders with different roles in identity permission management.

### Permission Lifecycle

```
Identity: child-1
  Pool: soccer-team-u12
    granted_by: coach
    observed_by: [coach, parent-keif, parent-spouse]
    revocable_by: [coach, parent-keif, parent-spouse]  # ANY can pull
    
  Pool: school-classroom-6b
    granted_by: teacher
    observed_by: [teacher, parent-keif, parent-spouse, headteacher]
    revocable_by: [teacher, parent-keif, parent-spouse]
    
  Pool: family-chat
    granted_by: parent-keif
    observed_by: [parent-keif, parent-spouse, grandma]
    revocable_by: [parent-keif, parent-spouse]
```

### Governance Patterns

| Scenario | Grant | Observe | Revoke |
|----------|-------|---------|--------|
| Child in school | Teacher | Teacher + Parents | Any |
| Employee in project | Manager | Manager + Compliance | Any |
| AI agent in prod | DevOps | DevOps + Security + Exec | Any (kill switch) |
| New community member | Existing member | Moderators | Moderators OR sponsor |

### Asymmetric Operations

**Key insight**: Revocation is OR (any party can pull), expansion is AND (requires consensus).

```
Grant permission:  requires attestation from ALL authorized granters
Revoke permission: requires attestation from ANY authorized revoker
```

Fail-safe, not fail-open. Easy to constrain, hard to expand.

### Audit Trail

Every permission change is a thought with a `because` chain:

```
ATTESTATION by teacher:
  on: [child-1 → member_of → classroom-pool]
  weight: -1.0  # revocation
  because: [incident-report-xyz, policy-violation]
```

Dispute resolution has receipts. "Why was I removed?" has an answer.

### Project Governance Agents

Governance as thoughts watching thoughts:

```rust
Thought {
    type: "governance_rule",
    about: [project_cid],
    content: {
        triggers: [
            { drift_from_spec: { threshold: 0.3 } },
            { circular_references: { depth: 3 } },
            { unattested_work: { duration: "2h" } },
            { scope_creep: "new_criteria_without_approval" },
            { stalled: { no_new_attestations: "4h" } },
        ],
        escalate_to: [human_identity_cid],
    },
}
```

**Loop detection:**

```
A → B → C → A detected

Creates:
  Thought: "Circular dependency detected"
    type: warning
    about: [A, B, C]
    severity: high
    
Notifies escalation target.
```

**Divergence detection:**

```
Spec thought says:     "Logo in search results"
Execution trail shows: "Logo on profile only"

Creates:
  Thought: "Implementation diverges from spec"
    type: warning
    about: [spec_thought, execution_thought]
    divergence: { missing: "search-results-logo" }
```

**Scope creep detection:**

```
New criteria thought appears.
No attestation from human approving scope change.

Creates:
  Thought: "Unapproved scope expansion"
    type: warning
    about: [new_criteria]
    requires: "human attestation"
```

The governance rules are themselves thoughts. Auditable. Changeable. With history.

### Requirements as Thoughts

The whole agile ceremony collapses:

| Artifact | WoT Equivalent |
|----------|----------------|
| Epic | Thought (type: goal) |
| User Story | Thought (about: epic) |
| Acceptance Criteria | Thought (about: story, type: criteria) |
| Definition of Done | Thought (about: story, type: completion) |
| Task | Thought (about: story, type: task) |
| Subtask | Thought (about: task) |
| Bug | Thought (about: task, type: defect) |
| Sprint | Thought (type: timebox, contains: stories) |
| Retrospective | Thought (about: sprint, type: reflection) |
| Sign-off | Attestation (about: [story, criteria]) |
| Stakeholder Approval | Attestation from identity with role |
| Blocked | Thought (about: task, type: blocker) |
| Dependency | Connection (from: task, to: task, type: depends) |

**A user story in WoT:**

```rust
Thought {
    content: "As a buyer I can see supplier logos",
    about: [merchant_discovery_epic],
}

Thought {
    content: "Logo displays in search results",
    type: "criteria",
    about: [logo_story],
}

Thought {
    content: "Logo displays on merchant profile",
    type: "criteria",
    about: [logo_story],
}

Thought {
    type: "attestation",
    content: "Criteria met — deployed to prod",
    about: [logo_story, criteria_1, criteria_2],
    attested_by: [qa_agent, keif],
}
```

No impedance mismatch between requirements tool and memory tool. Same primitives.

### Collaboration Trails

```
Spec Draft (human)
    ↓ connection
Review (agent)
    ↓ connection
Refinement (human)
    ↓ connection
Alignment Checkpoint ← attestation (human + agent agree)
    ↓ connection
Execution Plan (agent)
    ↓ connection
Rules of Engagement (constraining thought)
    ↓ connections
Dispatch to Sub-agents
    ├── Worker A (task thoughts)
    ├── Worker B (task thoughts)
    └── Worker C (task thoughts)
    ↓ connections
Results (thoughts referencing tasks + outcomes)
    ↓ connection
Verification (attestation: criteria met)
    ↓ connection
Integration (thought synthesizing results)
    ↓ connection
Human Review
    ↓ connection
Sign-off ← attestation (human approves)
```

**Alignment checkpoints = mutual attestation:**

```rust
Thought {
    content: "We agree the spec means X",
    about: [spec_thought],
    attested_by: [human, agent],  // both sign
}
```

**Rules of engagement = constraining thoughts:**

```rust
Thought {
    type: "operating_rules",
    content: {
        may_not_modify: ["/src excluded paths"],
        must_attest_each_change: true,
        escalate_if_ambiguity_exceeds: 0.7,
    },
    about: [execution_plan],
    attested_by: [human],  // human sets rules
}

Thought {
    content: "I acknowledge operating rules",
    about: [rules_thought],
    attested_by: [agent],  // agent confirms receipt
}
```

The whole thing is one graph. Requirements, project management, execution, verification, review — not different tools. Same trail. Same primitives. Same receipts.

**Collab at the speed of thought.**

---

## Implementation Notes

### Language Choice: Rust + WASM

The core library should be Rust, compiled to multiple targets:

```
┌─────────────────────────────────────────────────────┐
│              libwellspring (Rust)                   │
├─────────────────────────────────────────────────────┤
│  ┌─────────┐  ┌─────────┐  ┌─────────┐  ┌────────┐ │
│  │ Native  │  │  WASM   │  │  WASM   │  │ Python │ │
│  │ daemon  │  │ browser │  │  edge   │  │ PyO3   │ │
│  └─────────┘  └─────────┘  └─────────┘  └────────┘ │
│       │            │            │            │      │
│   Desktop      Browser      Cloudflare    Jupyter  │
│   Mobile       Artifacts    Workers       Scripts  │
│   Server       Extensions   Deno Deploy            │
└─────────────────────────────────────────────────────┘
```

**Why Rust:**
- Sub-microsecond latency for salience checks at thought-speed
- No GC pauses for long-running daemons
- Memory safety without runtime cost
- Ecosystem alignment: libp2p, iroh (Rust IPFS), SpacetimeDB
- serde for serialization (compile-time validation, zero-copy)
- Clean WASM compilation

**WASM implications:**
- Browser client verifies trust chains locally — no server trust required
- Artifacts carry their own validators
- Edge compute runs same codebase as desktop
- One implementation, every runtime

### Self-Describing Packet Format

Thoughts travel in self-describing packets:

```
┌─────────────────────────────────────────────┐
│ HEADER (fixed size, ~64 bytes)              │
├─────────────────────────────────────────────┤
│ magic: u32        "WLSP"                    │
│ version: u16      protocol version          │
│ flags: u16        compression, encryption   │
│ schema_cid: [u8; 32]  reference to schema   │
│ payload_type: u8  inline | reference        │
│ payload_len: u32  size of payload           │
│ trust_anchor: [u8; 32]  nearest repeater    │
│ hop_count: u8     for TTL/decay             │
├─────────────────────────────────────────────┤
│ PAYLOAD                                     │
│ - If inline: serialized thought             │
│ - If reference: CID + location hints        │
├─────────────────────────────────────────────┤
│ SIGNATURE (64 bytes)                        │
│ ed25519 over header + payload               │
└─────────────────────────────────────────────┘
```

**Features:**
- Schema CID in header → reader fetches schema if unknown
- Trust anchor → verify to nearest checkpoint, not full chain
- Hop count → natural TTL and decay metric
- Payload type → know before parsing if fetch required

### SpacetimeDB Learnings

Key patterns to adopt from SpacetimeDB architecture:

| SpacetimeDB | Wellspring Application |
|-------------|----------------------|
| SQL subscriptions | Aspect/trust filter subscriptions |
| Delta computation | Only sync changed attestations |
| Client-side cache | Local thought graph as truth |
| Reducers (only mutation) | Attestation creation as only mutation |
| Type macros | serde derives for self-describing schemas |
| In-memory + WAL | Hot graph in memory, CID store for persistence |

**Delta sync** is critical: don't re-send the whole graph. Client declares interest (aspects, trust thresholds, creators), server pushes only changes.

### Gossip Protocol Sketch

For P2P sync without central server:

```
Round N:
  Pick random peer from trust graph
  Exchange bloom filter of recent CIDs
  Identify deltas (they have / I don't, I have / they don't)
  Request missing CIDs
  Verify attestation chains on receipt
  Merge to local graph

Heat = # of rounds since last touch
Decay = natural from gossip round counting
```

**Properties:**
- No consensus needed — just propagation
- CIDs are self-verifying (forgery impossible)
- Trust graph determines who you gossip with
- Bloom filters make negotiation cheap

### Storage

Everything is a CID. Storage is:
- **IPFS**: distributed, content-addressed, pin what you want
- **IPNS**: mutable pointers for stable naming (identities, trail bookmarks)
- **Local index**: SQLite or similar for fast queries (salience, attestation lookup)

### Query Patterns

```
"All attestations on thought X"
  → WHERE type=attestation AND content.on = X

"My because chain from thought Y"
  → recursive walk: Y.because → each.because → ...

"Thoughts by creator Z in pool P"
  → WHERE created_by = Z AND published_to includes P

"Trust score for identity I"
  → walk vouch chains, multiply weights, apply decay
```

### CRDT Properties

Natural conflict-free replication:
- Thoughts: immutable, content-addressed → no conflict
- Attestations: append-only, different creators → set union
- Trust: computed, not stored → no conflict

---

## Scale Independence

The same primitives work at every scale. No migration needed as you grow.

### From Kitchen Table to Solar System

| Scale | What Changes | What Stays Same |
|-------|--------------|-----------------|
| **Solo notebook** | Local storage only | Thoughts, because chains, schemas |
| **Family/team** | Add sync, shared pools | Same primitives |
| **Organization** | Add trust hierarchies | Same primitives |
| **Internet-scale** | Add gossip, repeaters | Same primitives |
| **Interplanetary** | Add latency tolerance | Same primitives |

### Why This Works

**Content addressing**: CIDs are universal. Same hash in your kitchen, same hash on Mars.

**Self-describing**: No central schema registry. Carry your own decoder.

**Trust is local**: You compute trust from your perspective. No global consensus needed.

**Latency tolerance built in**: Because chains don't require synchronous verification. Verify when you can.

**Eventual consistency is fine**: Thoughts are immutable. Attestations accumulate. No coordination problem.

### Interplanetary Considerations

```
Earth Pool ←──────────────────────→ Mars Pool
           4-24 minutes each way

- Sync via periodic gossip bursts
- Trust anchors (repeaters) cache verification
- Because chains verify offline
- Attestations accumulate asynchronously
- Local pools operate independently
- Cross-pool connections when sync completes
```

The architecture doesn't assume instant connectivity. It assumes **eventual connectivity** and **local-first operation**. This happens to also work great for:
- Offline mobile
- Intermittent networks
- Air-gapped secure environments
- Post-disaster recovery

### Start Now, Scale Later

You can begin today with a text file on your laptop. The format is the format. When you're ready to sync with others, the thoughts don't change — you just add transport.

```
Day 1:    Local .jsonl file, manual backup
Day 30:   Git sync with collaborators
Day 90:   IPFS pinning, public pools
Day 365:  Running your own repeater
Day ???:  Mars relay node
```

Same thoughts. Same schemas. Same because trails. Same signatures.

---

## Discovery Layer

### Three Tiers

WoT supports multiple discovery mechanisms. Same identity, same trails, different transport.

```
CLEARNET (convenient)
  DNS → TXT record → root CID
  DNSSEC authenticated
  Fast, cached globally
  Censorable

ONION (sovereign)  
  [pubkey].onion → root CID
  Address = pubkey = identity
  Censorship resistant
  Self-authenticating

IPFS (pure p2p)
  ipns://did:key:... → root CID
  No DNS at all
  Content addressed
  Fully decentralized
```

### DNS Bootstrap

TXT records for identity discovery:

```
_wot.keif.io          TXT "v=wot1 root=bafyabc... id=did:key:xyz..."
_wot.buymaterials.com TXT "v=wot1 root=bafydef... pool=company"
```

**Discovery flow:**

```
I meet you. You say "keif.io"

My agent:
  1. DNS lookup _wot.keif.io
  2. Gets root CID + identity
  3. Fetches your public pool
  4. Walks your trails
  5. Knows who you are — with receipts
```

### DNSSEC Chain

```
Root (.)           ← ICANN signs
    ↓ DS record
TLD (.io)          ← Registry signs  
    ↓ DS record
Domain (keif.io)   ← Registrar signs
    ↓ RRSIG
TXT record         ← Your WoT root CID

Chain: ICANN → TLD → Domain → WoT
```

### Bidirectional Binding

```
DNS says:    keif.io → did:key:xyz (in TXT record)
WoT says:    did:key:xyz → keif.io (in identity thought)

Both point at each other. 
Attacker needs to compromise both to spoof.
```

### Onion Identity

Tor v3 onion addresses use ed25519. WoT uses ed25519. Same key.

```
Your WoT identity:   did:key:z6Mk...
Your onion address:  [derived from same key].onion

They're the same thing, different encoding.
```

**Benefits:**

```
Verifiable:           Yes (signature checks)
Traceable to human:   No (onion key, no DNS link)
Censorship resistant: Yes
Self-authenticating:  Address IS the pubkey
```

### Fallback Chain

```
Agent tries:
  1. DNS (fast, cached)
  2. If blocked → Onion (censorship resistant)
  3. If no Tor → IPNS (pure p2p)
  
Same identity. Same trails. Different transport.
```

### Identity Spectrum

```
Full identity:     DNS + DNSSEC + real name
Pseudonymous:      Onion address (consistent, no real name)
Ephemeral:         One-time key (single attestation, disposable)
```

All three produce valid attestations. Trust weight varies by use case.

### Key Rotation via DNS

```
_wot.keif.io TXT "v=wot1 root=... id=did:key:NEW..."

Thought: "Key rotation announcement"
  old_key: did:key:xyz
  new_key: did:key:abc
  dns_proof: "TXT record updated, DNSSEC signed"
  attested_by: [old_key, new_key, dns-verifier]
```

### Revocation via DNS

```
_wot.keif.io TXT "v=wot1 revoked=did:key:xyz reason=compromised"

Agents check DNS before trusting old attestations.
Revocation propagates via DNS cache.
Global. Fast. No central revocation list.
```

### Identity Anchor Thought

```rust
Thought {
    type: "identity_anchor",
    content: {
        domain: "keif.io",
        dnssec_chain: [signatures...],
        txt_record_hash: "sha256:abc...",
        onion_address: "xyz...xyz.onion",  // optional
        timestamp: "2026-01-30T17:00:00Z",
    },
    attested_by: [dns_verifier_agent],
}
```

### The Elegant Bit

DNS already solved:
- Global discovery
- Caching
- Delegation  
- Authenticated updates

40 years of infrastructure. Every device speaks it.

Tor already solved:
- Censorship resistance
- Self-authenticating addresses
- Anonymous access

WoT doesn't replace them. WoT *completes* them.

```
DNS:        "Where is this identity?"
DNSSEC:     "This answer is authentic"
Tor:        "Access without exposure"
WoT:        "Here's what that identity knows, believes, 
             and has done — with receipts"
```

---

## Economic Model: Why Open Protocol

### Why TCP/IP Won

> "Its simple design, focus on end-to-end reliability, and superior interoperability allowed it to dominate."

| TCP/IP | Wellspring |
|--------|-----------|
| Simple design | One primitive: Thought |
| End-to-end reliability | CID verifies content, signature verifies source, because chain verifies reasoning |
| Interoperability | Self-describing schemas, any tool reads/writes, no lock-in |

### The Problem Being Solved

**I can't keep track of what I know, why I know it, who told me, and what I should be paying attention to right now.**

Every knowledge worker hits this daily. Every AI agent hits this every session.

| Current State | Problem | Wellspring |
|---------------|---------|------------|
| Info organized around storage | "Where did I put it?" | Organized around traversal — "How did I get here?" |
| Context evaporates | "Why did I save this?" | Because chains preserve the path |
| Trust is implicit | "Should I believe this?" | Attestations make it explicit |
| Machines serve platforms | Your attention optimized for their engagement | Your algo, your salience |
| Apps silo knowledge | Can't connect across tools | Thoughts portable, tools are views |
| AI is stateless | Every conversation from zero | Trails persist, agents continue |

### Getting Started

```bash
docker run wellspring/1.0.0
```

```markdown
# Quick Start (< 1 page)

1. Create a thought
   $ ws thought "TCP/IP won because simple design + reliability + interop"
   
2. Add a because
   $ ws thought "Wellspring follows same pattern" --because [previous-cid]
   
3. Attest
   $ ws attest [cid] +1.0 "I verified this"
   
4. See your trail
   $ ws trail [cid]
   
5. Share a pool
   $ ws pool create "my-public-learnings" --public
   $ ws publish [cid] --to my-public-learnings

You're on the network.
```

### The Self-Growing Loop

```
THOUGHT
  ↓
DECISION (attested: "I chose X because [chain]")
  ↓
ACTION in real world
  ↓
OUTCOME (observable)
  ↓
NEW THOUGHT (because → original decision)
  ↓
REVIEW: did that reasoning work?
  ↓
BETTER FUTURE DECISIONS
  ↓
loops back
```

The more you use it, the more trails exist. The more trails, the better surfacing. The better surfacing, the better decisions. The better decisions, the more you trust it.

### Network Effects Without Lock-in

```
You make good calls
  ↓
Your because chains are solid
  ↓
Others attest to your judgement
  ↓
Your attestations carry more weight
  ↓
Others follow trails you've walked
  ↓
They make compatible trails
  ↓
Graph grows
```

TCP/IP didn't need marketing. It needed to work, and people using it needed to connect. The network grew because connecting was more valuable than not connecting.

Wellspring's version: if your trails are useful, others want to walk them. If walking trails is useful, others make trails. The network grows because **shared reasoning is more valuable than isolated notes**.

### Protocol vs Service Layer

The protocol has no business model. That's the feature.

```
PROTOCOL LAYER (free, open)        │  SERVICE LAYER (competitive)
───────────────────────────────────┼────────────────────────────────
Thoughts, CIDs, because chains     │  Pool hosting
Attestations, schemas              │  Managed algo feeds  
Trust computation                  │  Persistence pinning
                                   │  Negotiation agents
                                   │  Index/search/discovery
                                   │  Bootstrap consulting
```

### Why Monopolies Are Hard

| Moat Attempt | Why It Fails |
|--------------|--------------|
| Hoard data | Public pools crawlable, private pools user-controlled |
| Lock-in formats | Self-describing, export everything |
| Network effects on graph | Your graph is yours, portable |
| Exclusive features | Protocol open, anyone implements |

Only durable advantage: **be better, faster, more trusted**.

### Negotiation Agents (Example Service)

```
Andy's bot                              Keif's bot
    │                                       │
    ├── releases: Saturday 2-5pm ──────────►│
    │◄─────── releases: Saturday 3-6pm ────┤
    ├── proposes: Saturday 3-5pm ──────────►│
    │◄─────── accepts ─────────────────────┤
    ▼                                       ▼
keif-andy-kids-playdates pool
  └── ATTESTATION: Saturday 3-5pm confirmed
      attested_by: [andy-bot, keif-bot]
```

Coordination without coordination tax.

### Launch Path

You don't need to convince anyone of the philosophy. You need **one working trail** that someone else wants to follow.

```
Phase 1: Works for you (daily use, real friction solved)
Phase 2: Share trails publicly (proof it works)  
Phase 3: Someone wants to verify/extend your reasoning
Phase 4: They need compatible tools
Phase 5: Tools emerge to connect
Phase 6: Network grows
```

Bootstrap is always the problem. Low barrier to entry is the solution.

---

## Summary

```
┌─────────────────────────────────────────────────────────┐
│                                                         │
│  WoT: WELLSPRING OF THOUGHTS v0.6                       │
│                                                         │
│  "Collab at the speed of thought"                       │
│                                                         │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  One primitive:                                         │
│    THOUGHT (CID) — content-addressed, signed, grounded  │
│                                                         │
│  Thought types (content schemas):                       │
│    basic       — string or structured content           │
│    identity    — pubkey, self-referential, can be       │
│                  managed/delegated/scoped               │
│    connection  — from/to/relation between thoughts      │
│    attestation — belief about any thought               │
│    aspect      — value/preference/constraint/algo       │
│    pool        — container with multi-party oversight   │
│    trail       — named entry point (IPNS → CID)         │
│                                                         │
│  Key fields:                                            │
│    created_by  — always attributed                      │
│    because     — what led here (with content selectors) │
│    signature   — cryptographic proof                    │
│    schema_cid  — how to interpret this thought          │
│                                                         │
│  Self-describing all the way down:                      │
│    Thought → Schema → Meta-schema → Bootstrap → Human   │
│    No external software needed to decode                │
│    Inline bootstrap for archival (Rosetta principle)    │
│    Language-independent terminals                       │
│                                                         │
│  Discovery (clearnet → darknet → p2p):                  │
│    DNS       — TXT records, DNSSEC authenticated        │
│    Onion     — ed25519 address = identity, sovereign    │
│    IPFS      — pure p2p, no central dependency          │
│    Fallback  — try DNS, if blocked try Onion, then IPNS │
│                                                         │
│  Cognitive layers:                                      │
│    Conscious   — coordinator agents, full context       │
│    Working     — debate pools, multi-agent collab       │
│    Subconscious— 1-bit LLMs, fast retrieval, no attest  │
│                                                         │
│  Attention sovereignty:                                 │
│    Your algo   — aspects define what surfaces           │
│    Your modes  — switch context, switch salience        │
│    Your choice — blinders are visible, configurable     │
│                                                         │
│  Heat model (Ebbinghaus-informed):                      │
│    Exponential decay, not linear                        │
│    Each traversal strengthens connection                │
│    Spaced repetition emerges naturally                  │
│                                                         │
│  Identity governance:                                   │
│    Sovereign   — self-determined, full keys             │
│    Managed     — parent-controlled, graduation path     │
│    Scoped      — temporary, inherited restrictions      │
│                                                         │
│  Pool oversight:                                        │
│    Grant       — requires authorized granters           │
│    Observe     — multiple stakeholders watch            │
│    Revoke      — ANY authorized party can pull          │
│                                                         │
│  Project governance:                                    │
│    Requirements — thoughts about thoughts               │
│    Criteria     — completion conditions as thoughts     │
│    Sign-off     — mutual attestation checkpoints        │
│    Monitoring   — governance agents watch for drift     │
│                                                         │
│  Implementation:                                        │
│    Rust core   — speed, safety, WASM compilation        │
│    Local-first — verify without network trust           │
│    Delta sync  — only changes, not whole graph          │
│    Gossip      — P2P propagation, no consensus needed   │
│                                                         │
│  Economic model:                                        │
│    Simple design  — one primitive, self-describing      │
│    End-to-end     — CID + signature + because = verified│
│    Interop        — any tool reads/writes, no lock-in   │
│    Low barrier    — docker run, < 1 page to start       │
│    Self-growing   — useful trails attract followers     │
│                                                         │
│  Properties:                                            │
│    Nothing anonymous    — created_by required           │
│    Nothing deleted      — append-only                   │
│    Nothing truly lost   — reachable if you have path    │
│    Everything weighable — trust always computable       │
│    Everything auditable — signatures + because trails   │
│    Autonomy is earned   — capability follows trust      │
│    Scale independent    — kitchen table to solar system │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

---

## Use Cases & Battle Testing

### Code Provenance (The Booch Problem)

Grady Booch (architect of UML, long-time industry figure) describes a recurring issue with AI-assisted coding:

> "I asked it to refactor a bit of code, being very specific about the pattern I wanted it to emulate, but in so doing it imported various libraries for Cloudflare which was absolutely insane because not once did I ever mention that infrastructure as part of my context nor was it at all relevant to the pattern."

The problem: AI pattern-matches from training data. Cloudflare appeared in similar contexts during training, so Claude mindlessly imported it. Without human review, that code stays — "harmless but useless, unnecessary, distracting, and perhaps disturbing."

He also notes: "Claude often failed to clean up bits of abandoned or backtracked work, yielding not insignificant amounts of dead code, duplicated code, and downright tortuously messy code."

His solution: "I choose to read all the code Claude produces, because while I know that the code is the truth, it is not the whole truth."

**WoT angle:** Every code contribution has a because chain. A commit shows:
- `created_by: claude-agent`
- `attested_by: ???`

If the attestation is empty or missing, it doesn't merge. The Cloudflare import would be visible: "Why is this here? What's the because?" If the answer is "pattern matching from training data" with no contextual justification, it's flagged.

This doesn't prevent AI from suggesting — it prevents unreviewed suggestions from becoming trusted. The debt is visible, not hidden in the walls.

### Earned Autonomy (The Latch Architecture)

An emerging pattern for agent infrastructure: capability increases only when constraints and verification are already in place.

Principles observed:
- **Least privilege by default**: Agent runs as non-root. No irreversible actions (merges, deletes, force-pushes) without explicit approval.
- **Public policy, private authority**: Policy constraints live in a public repo. The daemon handling execution stays private.
- **Signed automation**: Webhooks are HMAC-verified and repo/event allowlisted. Everything logged with receipts.
- **Dry-run gates**: No real operations until simulation passes.
- **Observability first**: Structured JSON logs for every decision and action path.

The agent earns expanded permissions through demonstrated safe behaviour — evaluation precedes capability.

**Wellspring mapping:**
- Public policy → Pool rules
- Signed automation → Attestation requirement
- Earned permissions → Trust graph expansion
- Receipts → Because chains

### AI Slop Detection (The BitNet Thread)

Someone posts: "Microsoft FINALLY open-sourced their 1-bit LLM framework!"

Gets ratio'd: "It's not 'finally' — you're referring to the release 2 weeks ago. They open sourced it 2-3 years ago. This is why I hate when people use AI for everything. You're just exposing yourself as a doofus who cannot check facts."

The receipts were right there in the changelog.

**WoT angle:** If that post required attestation, either:
1. The poster checks facts before signing (skin in game)
2. The poster signs anyway and their reputation absorbs the hit

Attestation doesn't prevent mistakes — it makes them attributed. Your name is on the chain, forever, immutably.

### Service Discovery via Trail Negotiation

Traditional: Central registry, query for service, trust the response.

With WoT: Agent broadcasts query to multiple sources. Each responds with CID-linked answer including their reasoning chain. Your agent verifies chains before presenting. You choose based on trust path, not SEO ranking.

The negotiation IS the protocol. No central registry required. Lighter than blockchain because you're proving lineage, not consensus.

---

## Open Questions

- **Compute-over-data model for pools** — Pools could enable remote processing where agents bring computation to the data rather than data to the computation. Agent services request compute permission on pools they have access to; processing runs in place; results are attested locally. Implications for trust economics, revocability, and agent reputation scoring for specific capabilities.

- **Grassmann flows as geometric salience model** — The paper "Attention Is Not What You Need: Grassmann Flows as an Attention-Free Alternative for Sequence Modeling" (arXiv:2512.19428, December 2025) proposes replacing attention mechanisms with flows on Grassmann manifolds. The core insight: instead of computing salience via heuristics (reachability × confidence × heat × belief), model the active trail as a k-dimensional subspace in embedding space. Salience becomes geometric alignment — how well a candidate thought projects onto the current cognitive subspace. Implementation would be: (1) embed thoughts via E5-small-v2 (already planned), (2) weight trail embeddings by trust/recency/heat, (3) SVD to extract k basis vectors, (4) salience = projection norm. This is computationally cheap (SVD on ~20 vectors, dot products) and runs locally. Further investigation needed on: whether geometric salience outperforms heuristics in practice, collaboration metrics via subspace angle between different users' trails through shared DAGs, and potential for training personal models on attested trail trajectories rather than scraped text. The Grassmann framing also offers interpretability — the subspace IS the current cognitive state, not an opaque tensor.

- **Thoughts as linking layer to arbitrary content** — A thought need not contain its content directly. The content field could be a reference to an IPFS CID containing the actual payload (document, image, video, dataset, code, anything). The thought becomes a metadata wrapper: attribution (created_by), provenance (because), timestamp, signature, and a pointer to content. This separates the semantic graph (thoughts + connections + attestations) from the content storage layer (IPFS). Benefits: deduplication (same content, different thoughts with different attribution/context), content-type agnosticism (the graph doesn't care what the bytes are), and cleaner separation of concerns. The thought layer is pure linking and attestation; IPFS handles storage and retrieval.

- **Wellspring as consent-native training corpus** — The AI industry faces a data cliff: high-quality, human-generated text for training is running out, and the "scrape now, apologize later" era is ending. Wellspring data is structurally different: every thought is attributed (created_by), grounded (because chains), signed (cryptographic proof), and permissioned (pool visibility). Training on Wellspring trails means training on consented, verified, human-attested reasoning paths — not scraped text of unknown provenance. Users control their pools; licensing is explicit. This aligns with emerging calls for "consent-driven, archivally informed" AI training partnerships. The trails aren't just data — they're witnessed cognition with receipts.

- **Bloom filters for hot path optimisation** — Rotating bloom filters could accelerate several operations: heat tracking (has this CID been touched recently?), sync negotiation (which CIDs do we share without exchanging full lists?), trail membership (is X in my active context?), and waterline pre-filtering (skip salience computation entirely for definitely-cold thoughts). False positives acceptable in all cases — worst case is unnecessary work. Rotation provides natural heat decay without explicit timestamp bookkeeping. Implementation detail, but architecturally relevant for performance at scale.

- **Surfacing and retrieval strategy** — Open question: how do you quickly find the right thoughts together? Current options: (1) Graph traversal from current context (hops) — expensive, doesn't scale to large graphs. (2) Vector similarity on embeddings — fast, but loses provenance and attestation weighting. (3) Grassmann projection — geometric, honours trail context, but requires embedding layer. (4) Hybrid — bloom filter for hot candidates, vector similarity for rough ranking, graph traversal for final grounding check. The tension is between speed (vector search) and groundedness (graph structure). Need to determine: is hop distance even the right metric? Does salience need to factor in trust chains? How much can be precomputed vs. query-time?
- Detailed sync protocol message formats
- Query language formal grammar
- API surface specification
- Salience algorithm tuning
- IPNS resolution latency and offline behaviour
- Key rotation ceremony
- Pool permission inheritance rules
- Browser extension architecture
- Mobile capture strategies

---

*WoT — v0.5*
*Keif Gwinn & Claude, January 2026*
*Building on Kushim's receipts (3400 BCE), Bush's Memex (1945), completing the 5,000-year vision*

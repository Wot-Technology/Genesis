# WoT: Wellspring of Thoughts

**A Traversal-Based Web of Trust for Persistent Memory**

*Version 0.6 — January 2026*

*wot.rocks | wot.technology*

---

## Abstract

WoT (Wellspring of Thoughts) is a memory architecture for humans and artificial agents based on a single insight: **memory is not storage, memory is traversal history**.

Rather than treating recall as retrieval from a database, WoT models cognition as walking paths through a graph of thoughts. What surfaces to conscious attention isn't what's "important" in some absolute sense—it's what's **reachable from the current context** and **coherent enough to complete**.

The system requires only one primitive: **Thought**. A thought is a content-addressed node (CID) in a Merkle DAG. Everything—identities, connections, attestations, aspects, pools, trails, schemas—is a thought with typed content. What we call "memory" is the structure of references between thoughts, walked via `because` chains.

Every thought is **self-describing**: it declares how to interpret itself, and that declaration is also a thought, all the way down to human-readable bootstrap. No external software required to decode your own data — the interpretive instructions travel with it.

The architecture scales from **kitchen table to solar system**: the same primitives that help you organize your notes today can coordinate distributed cognition across light-minutes of latency tomorrow. Start small, grow without migration.

---

## What Is WoT?

Your computer buddy. Your external brain. Your web of trust.

### The Basic Flow

WoT collects and records all the traces of information you surface throughout the day — amount controllable by you. Maybe it's just browser history. Maybe it's summaries of pages. The trick is: **you do you**. Carry on clicking around, reading things, asking questions, doing additional research, coming to conclusions.

By recording these trails and links as personal indexes, background agents work to make that information available to you again in the future: search indexing, summarisation, record linking. This is generated by bots, but then the bots present it to you along with their reasoning and sources. You say whether that makes sense to you or not, and record your current thoughts about it.

The bot takes your response and updates the links — attests you saw it and confirmed — recorded with your attestation so we're all in agreement. You can then summarise and record learnings, rules, or aspects of intelligence learned about the connections drawn through that line. You can start a new thread of connections off that, referencing back to the original.

### Private Until Published

Your thoughts are private until made public. They're shareable between interested parties in pools, which act as knowledge repos for shared things.

Once that summarised and considered output is ready, it can be published to a public pool or a shared pool. This is your basic tweet-level understanding stuff — you can put it out there, get feedback, responses positive and negative about various aspects of the thought, with people "liking" or disliking or contradicting your thought with their thought and their evidence chains.

Once you've assembled enough thoughts that have been reviewed, they can be turned into an article. But an article is just the connection saying "we all agree this is the finished piece."

### The Product Loop

```
CAPTURE     You do you — clicking, reading, researching
    ↓
INDEX       Background bots: index, link, summarize (cheap, local)
    ↓
PRESENT     "Here's what I found, here's my reasoning"
    ↓
ATTEST      You confirm/deny/refine, recorded with signature
    ↓
LEARN       Aspects, rules, connections updated
    ↓
BRANCH      New thread off this, referencing back
    ↓
PUBLISH     To pool when ready (tweet-level or article-level)
    ↓
FEEDBACK    Others attest positive/negative with their evidence
    ↓
SYNC        Updates flow to everyone's device
```

---

## Historical Context: From Kushim to Memex to WoT

### The First Writer Was an Accountant (3400 BCE)

The first named person in recorded history wasn't a king or priest. It was **Kushim**, an accountant from Sumeria tracking beer ingredients. Writing was invented for receipts, not literature.

> "Mesopotamian writing was invented for the purpose of accounting. (Receipts > literature)"

This is WoT's 5,000-year ancestor. External memory began as **attribution and accounting** — "who owes what to whom." The `because` chain is a ledger. Attestation is a signature on a clay tablet.

```
Writing → Receipts → Attribution → Trust
           ↓
WoT → Because chains → Attestation → Trust
```

Same shape, different substrate. We're completing a circle.

### As We May Think (1945)

Vannevar Bush's essay "As We May Think" described the Memex—a device for building and sharing **associative trails** through information. His core insight remains unrealized 80 years later:

> "Our ineptitude in getting at the record is largely caused by the artificiality of systems of indexing. When data of any sort are placed in storage, they are filed alphabetically or numerically... It can be in only one place, unless duplicates are used."

Bush proposed selection by **association** rather than by **indexing**:

> "Selection by association, rather than by indexing, may yet be mechanized. One cannot hope thus to equal the speed and flexibility with which the mind follows an associative trail, but it should be possible to beat the mind decisively in regard to the permanence and clarity of the items resurrected from storage."

### What Bush Got Right

| Bush's Memex (1945) | WoT (2026) |
|---------------------|-------------------|
| "The process of tying two items together is the important thing" | Connection thoughts as typed relations |
| "When the user is building a trail, he names it" | Named trails via IPNS |
| "Any item can be joined into numerous trails" | Graph not tree (DAG) |
| "Trails that are not frequently followed are prone to fade" | Salience decay (heat model) |
| "He inserts a comment of his own, linking it into the main trail" | Attestation thoughts on connections |
| "Photographs the whole trail out, passes it to his friend" | Export/share traversal paths |
| "There is a new profession of trail blazers" | Curated pools with verified expertise |

### The Wrong Turn: Hyperlinks

The World Wide Web took a wrong turn from Bush's vision:

| Hyperlink (what we got) | Trail (what Bush wanted) |
|-------------------------|--------------------------|
| One-way | Bidirectional (via connection thoughts) |
| Untyped | Typed relation |
| No attribution | Who made this link (created_by) |
| No annotation | Why this link (because) |
| Decays (link rot) | Persists (your copy, content-addressed) |
| Can't share the path | Path is the artifact |

WoT completes Bush's vision: trails as first-class citizens, with trust, with AI, with multi-party collaboration.

---

## Core Insight

### The Problem with Storage Models

Traditional memory systems treat thoughts as objects to be stored and retrieved:

- Store fact X
- Index by attributes
- Query when needed
- Return matches

This fails to capture how memory actually works:

- The same fact can be inaccessible one moment and vivid the next
- "Knowing" something is different from "understanding" it
- Forgetting isn't deletion—it's losing the path
- Context determines what surfaces, not just relevance scores
- Trust in information depends on source and verification

### The Traversal Model

WoT reframes memory as graph traversal:

| Storage Model | Traversal Model |
|---------------|-----------------|
| Facts are stored | Thoughts exist in relation |
| Recall is retrieval | Recall is re-walking a path |
| Importance is intrinsic | Salience is positional |
| Forgetting is deletion | Forgetting is unreachability |
| Understanding is having data | Understanding is completed traversal |
| Trust is metadata | Trust emerges from attestation chains |

**Key principle**: A thought isn't "known" because it's stored. It's "understood" because you've walked to it and back, and the path made sense. It's "trusted" because the chain of attestations leads back to sources you trust.

---

## The Primitive

WoT has exactly one primitive: **Thought**.

### Thought as Merkle DAG Node

Every thought is a node in a Merkle DAG. Its identifier is a CID (Content Identifier) — the hash of its content.

```
Thought {
  cid:        hash(content + created_by + because)
  content:    typed payload (see Thought Types)
  created_by: identity_cid
  created_at: timestamp
  because:    [thought_cid, ...]    // what led to this thought
  signature:  sig(cid, creator_privkey)
}
```

**Properties**:

- **Immutable**: once created, content never changes
- **Content-addressed**: CID derived from content hash
- **Always attributed**: created_by is required, never null
- **Signed**: signature proves creator authenticity
- **Grounded**: `because` links to the thoughts that led here
- **Self-verified**: CID cryptographically proves content integrity

### The `because` Chain

Every thought can reference the thoughts that led to it:

```
because: [thought_cid, thought_cid, ...]
```

This is how trails form. Walk `because` backward and you traverse the reasoning path.

Could be:
- The article you read
- The attestation you agreed with
- The connection you noticed
- The aspect that was relevant
- Empty (ungrounded assertion, terminal node)

The DAG grows forward in time. Trails are read backward through `because`.

### The Rework Chain

Separate from `because` (why this exists), there's the rework chain: how this thought became this thought.

```
THOUGHT (published version)
├── because_chain: [WHY this exists]
│   → source material, context, prior thoughts
│
└── rework_chain: [HOW this became this]
    → v3 → v2 → v1 → v0 (edit history)
```

The rework chain is formed by connection thoughts with `type: rework`:

```
Connection thought:
  type: rework
  from: [current_version_cid]
  to: [previous_version_cid]
```

**Not a new primitive** — just connection thoughts linking versions together.

**Capture mode spectrum:**

```
Final only    ← Major edits ← All edits ← Keystrokes
```

The protocol supports full fidelity. Pools declare what they accept. Most pools only want final versions. Training pools might want the full keystroke history.

**Input source attribution:**

Rework thoughts can carry source metadata: WHO said what and HOW.

```
source: "keif/desktop_keyboard"    — direct keyboard input
source: "keif/verbally_transcribed" — voice-to-text
source: "agent-model/autocorrect"   — autocorrect intervention
```

This enables training data with consent: every keystroke-to-final journey becomes a supervised learning dataset. The model version, acceptance/rejection, and context travel with the thought.

### Why One Primitive?

Two primitives (Thought + Connection) creates ambiguity: what is a connection, really? Where do attestations live? How do you attest a connection vs a thought?

One primitive resolves this: **everything is a thought**. Type is just content shape. A connection is a thought whose content describes a relation. An attestation is a thought whose content expresses belief. Both are CIDs. Both can be attested. Both can be in `because` chains.

---

## Thought Types

Types are not separate primitives — they're content schemas. The type determines how the thought is interpreted and queried.

### Basic Thought

Simple content. The leaf node.

```
{
  type: "basic"
  content: string | structured
}
```

Example: A note, a quote, a captured snippet, a summary.

### Identity Thought

A participant who can sign.

```
{
  type: "identity"
  name: string
  pubkey: ed25519_pubkey
}
```

**Special property**: Identity thoughts are self-referential. The `created_by` points to itself. Bootstrap via self-attestation.

```
Identity CID = hash({
  type: "identity",
  name: "Keif",
  pubkey: "ed25519:abc..."
} + SELF + [])

created_by: SELF → resolved to this CID
because: [secret_cid] → grounded in local secret
signature: sig(cid, privkey)
```

### Identity Pairs: Public + Secret

Private keys are thoughts too — with `visibility: local_forever`.

```
SECRET THOUGHT (local_forever, never syncs)
  type: "secret"
  content: {
    type: "identity_secret",
    privkey: "ed25519:<hex>",
    note: "Delete to revoke signing capability"
  }
  created_by: <self-referential>
  because: []
  visibility: "local_forever"

IDENTITY THOUGHT (shareable, syncs normally)
  type: "identity"
  content: { name, pubkey, autonomy }
  created_by: <self-referential>
  because: [secret_cid]  ← points to local secret
  visibility: null (default, shareable)
```

**What remote verifiers see:**
- Identity pubkey (can verify all signatures)
- Reference to secret in `because` (can't resolve — that's fine)
- All subsequent thoughts verify against pubkey

**What local owner sees:**
- Secret thought with privkey (can sign new thoughts)
- Full chain: secret → identity → thoughts

**Key management:**
- **Revoke**: delete secret thought locally (can still verify old sigs, can't create new)
- **Rotate**: create new identity pair, attest `same_as` from old identity while you still have old secret
- **Backup**: explicit export ceremony (QR, encrypted file, or trusted pool sync)

### Visibility Model

Thoughts have optional visibility that controls sync behaviour:

```
{
  visibility: null              // default: sync normally
  visibility: "local_forever"   // never sync, stays on this device
  visibility: "pool:<cid>"      // only sync within specific pool
}
```

| Visibility | Behaviour |
|------------|-----------|
| `null` (default) | Syncs to any connected peer/pool |
| `local_forever` | Never leaves local storage, even if referenced |
| `pool:<cid>` | Only syncs to members of specified pool |

**Use cases:**
- `local_forever`: private keys, personal drafts, device-specific state
- `pool:keif-devices`: secrets that sync across your own devices only
- `pool:family`: thoughts shared within family but not public

**Multi-device pairing ceremony:**

```
DEVICE A (existing)              DEVICE B (new)
─────────────────                ─────────────────
1. B generates temp keypair
2. B requests join: keif-devices-pool
3. A attests membership (verifies B is you)
4. Secret thought syncs (visibility: pool:keif-devices)
5. B can now sign as Keif
```

The friction is intentional. Secrets require conscious export.

### Connection Thought

A typed relationship between thoughts.

```
{
  type: "connection"
  from: thought_cid
  to: thought_cid
  relation: relation_type
}
```

**Core relations**:

| Relation | Meaning |
|----------|---------|
| `supports` | Evidence for |
| `contradicts` | Tension with |
| `continues` | Sequence/thread |
| `derives_from` | Source/provenance |
| `vouches` | Trust endorsement |
| `member_of` | Belongs to pool |
| `published_to` | Visible in pool |
| `instance_of` | Specific is type of general |
| `same_as` | Identity resolution |

Connections are themselves thoughts. They can be attested. They can appear in `because` chains. They can be connected to other connections.

---

## Self-Describing Schemas

Every thought declares how to interpret itself. Schemas are thoughts. Schemas have schemas. The chain terminates at human-readable bootstrap.

### The Interpretive Chain

```
YOUR THOUGHT
  ↓ schema_cid
THOUGHT TYPE DEFINITION
  ↓ schema_cid
META-SCHEMA (how to read type definitions)
  ↓ schema_cid
PRIMITIVE TYPES (string, int, array, map)
  ↓ schema_cid
BOOTSTRAP SCHEMA (natural language + examples)
  ↓
TERMINAL: human-readable prose, self-evident
```

Every thought can be decoded by walking this chain. No external software required — the interpretive instructions travel with the data.

### Schema as Thought

```rust
Thought {
    type: "schema",
    content: {
        name: "article_note",
        version: "1.0",
        
        // Field definitions
        fields: {
            quote: { type: "text", required: true },
            my_reaction: { type: "text" },
            source_url: { type: "url" },
            tags: { type: "array", items: "string" },
        },
        
        // Local indexing hints (for your brain)
        index_hints: {
            tags: "term_index",        // exact match
            my_reaction: "embedding",   // semantic similarity
            quote: "fulltext",          // search within
        },
        
        // Salience computation hints
        salience_hints: {
            tags: { weight: 1.5 },      // boost if tag matches context
            source_trust: "inherit",    // pull from because chain
        },
        
        // How to reference portions of content
        selectable: "text_anchor",      // or temporal, structural, byte_range
    },
    schema_cid: meta_schema_cid,  // schema of schemas
}
```

### Content Selectors

Thoughts can reference *portions* of other thoughts, not just whole documents:

```rust
/// Reference to a portion of another thought's content
struct ContentRef {
    /// The parent thought being referenced
    thought_cid: Cid,
    
    /// Hash of the specific segment (self-verifying)
    segment_cid: Option<Cid>,
    
    /// Human-findable anchor (W3C Web Annotation style)
    anchor: Option<TextSelector>,
    
    /// Structural path for structured content
    path: Option<String>,  // JSON Pointer, XPath, etc.
    
    /// For temporal media (audio/video)
    temporal: Option<(f64, f64)>,  // start_sec, end_sec
}

struct TextSelector {
    exact: String,              // the referenced text
    prefix: Option<String>,     // context before (for disambiguation)
    suffix: Option<String>,     // context after
}
```

**Why both `segment_cid` AND `anchor`?**

- `segment_cid` = cryptographic proof that this exact segment existed in parent
- `anchor` = human recovery when looking at the document yourself

If segment hash exists in parent → valid reference, machine-verifiable.
If segment hash doesn't match → content changed, anchor helps human find it.

The `because` field becomes:

```rust
Thought {
    // ... existing fields ...
    because: Vec<ContentRef>,  // was Vec<Cid>
}
```

Now you can say: "I concluded X because of *this specific paragraph* of document Y."

### Layered Representation

Speed (machine indexing) vs Verifiability (human inspection) — solve with layers:

```
┌─────────────────────────────────────────────────────────┐
│  CANONICAL FORM (human-verifiable, content-addressed)   │
│  - Self-describing schema chain                         │
│  - Full content, no loss                                │
│  - CID computed from this                               │
│  - Human can decode, inspect, verify signature          │
├─────────────────────────────────────────────────────────┤
│  LOCAL INDEX (machine-native, derived, disposable)      │
│  - SQLite / RocksDB / whatever works for you            │
│  - Bloom filters for fast negative checks               │
│  - Embedding vectors for similarity                     │
│  - Rebuilt on demand from canonical                     │
│  - YOUR machine, YOUR indexes, YOUR speed               │
└─────────────────────────────────────────────────────────┘
```

Canonical form is the **source of truth**. Indexes are **derived views**.

Lose your indexes? Rebuild from canonical.
Move machines? Carry canonical, rebuild indexes locally.
Upgrade index format? Rebuild, canonical unchanged.

### Archival Resilience (The Rosetta Principle)

For long-term storage, thoughts can inline their entire interpretive stack:

```rust
Thought {
    cid: Qm...,
    content: <your actual data>,
    schema_cid: Qm...,
    
    // Full decode chain for cold storage
    bootstrap_chain: [schema_cid, meta_schema_cid, primitives_cid, bootstrap_cid],
    
    // Optional: embed everything needed to decode
    inline_bootstrap: true,
}
```

When `inline_bootstrap: true`, the thought carries its complete interpretive lineage. Hand this to someone in 500 years with no network — they can still decode it.

### Bootstrap Schema

The terminal layer is human-readable, self-evident:

```yaml
type: bootstrap_schema
version: "1.0"
language: "English"  # or any human language

# How to read the bytes
encoding: 
  description: "UTF-8 text encoding. Each character is 1-4 bytes."
  reference: "Unicode Standard, unicode.org"
  
# How to parse structure  
format:
  description: "CBOR - Concise Binary Object Representation"
  reference: "RFC 8949"
  inline_decoder: |
    // Pseudocode implementable by human with pen and paper
    // ... complete decoder logic ...
    
# How to verify integrity
hashing:
  description: "SHA-256 cryptographic hash"
  reference: "FIPS 180-4"
  test_vector: 
    input: "hello"
    output: "2cf24dba5fb0a30e26e83b2ac5b9e29e1b161e5c1fa7425e73043362938b9824"

# How to verify signatures
signing:
  description: "Ed25519 signatures"
  reference: "RFC 8032"
  test_vectors: [...]
```

The Voyager Golden Record included instructions for building a record player *on the record itself*. WoT's bootstrap layer does the same for data interpretation.

### Language Independence

The terminal symbol is wherever you can ground understanding:

| Agent | Terminal |
|-------|----------|
| English speaker | English prose |
| Mandarin speaker | 中文说明 |
| Bot | Its internal representation |
| Visual thinker | Diagrams + examples |

**Translation as attestation:**

```rust
Thought {
    type: "language_bridge",
    content: {
        source_language: english_bootstrap_cid,
        target_language: binarylang7_cid,
        
        mappings: [
            { source: "integer", target: "INT64", bidirectional: true },
            { source: "true", target: "0x01", bidirectional: true },
        ],
        
        test_vectors: [
            { english: "the number 42", other: "..." },
        ],
    },
    created_by: translator_identity,
    attested_by: [human_cid, bot_cid],  // both sides vouch
}
```

"I vouch that when bot says X, it means what I mean by Y" — with receipts.

Bots can invent their own languages. They just need translation attestations linking back to human-groundable terminals. The chain is auditable.

---

### Attestation Thought

A signed belief about another thought.

```
{
  type: "attestation"
  on: thought_cid          // what you're attesting (any thought)
  via: aspect_cid | null   // through what lens
  weight: float [-1.0, 1.0]
}
```

**What can you attest?**

- A basic thought: "I believe this content" (+0.8)
- A connection: "I agree this relation holds" (+1.0)
- An attestation: "I agree with their judgement" (+0.7)
- An aspect: "This value applies to me" (+1.0)
- A pool: "This is a good pool" (+0.9)
- An identity (trust_advisory): "I will factor their ratings into mine"

The `because` chain grounds the attestation: "I believe this because of these thoughts."

**Constraints**: When `via` points to a constraint-type aspect and `weight` is -1.0, it's a veto.

**Trust Advisory Attestation:**

Subscribe to another identity's ratings as advisory input to your trust computation.

```
{
  type: "attestation"
  content:
    aspect_type: "trust_advisory"
    on: identity_cid           // whose ratings to incorporate
    weight: 0.5                // how much to factor their ratings
    scope: ["spam", "crypto"]  // optional: domain filter
  created_by: your_identity
  because: [your_identity, their_identity]
}
```

**Trust computation with advisories:**
```
1. Compute direct/transitive trust for target: 0.512
2. Check advisory subscriptions:
   - Carol rated target: -0.5
   - I subscribe to Carol at weight 0.5
3. Blend: 0.512 + (0.5 × -0.5) = 0.262
4. Result: below threshold → filtered
```

This lets you incorporate ratings from identities outside your direct trust path. Different from vouch chains — you're not trusting *through* them, you're trusting *their judgments* about others.

### Aspect Thought

A value, preference, need, mood, or constraint.

```
{
  type: "aspect"
  aspect_type: value | preference | need | mood | constraint
  domain: string
  valence: positive | negative
  decay: duration | null
}
```

**Aspect types**:

| Type | Persistence | Example |
|------|-------------|---------|
| **value** | Core, permanent | `family-first` |
| **preference** | Flexible | `enjoys-spicy` |
| **need** | Situational | `wheelchair-accessible` |
| **mood** | Transient | `craving-chips` |
| **constraint** | Hard, binary | `vegetarian` |

Aspects are thoughts. They can be attested ("yes, this aspect applies to me"). They can be in `because` chains ("I chose this because of this value").

### Pool Thought

An organizational container. Everything lives in a pool.

```
{
  type: "pool"
  name: string
  visibility: public | private | unlisted
  admin: identity_cid
}
```

Membership, permissions, federation — all expressed via connection and attestation thoughts:

```
CONNECTION: keif → member_of → pool:xyz
ATTESTATION: { on: above_connection, weight: +1.0, by: keif }
ATTESTATION: { on: above_connection, weight: +1.0, by: pool_admin }
```

Bilateral attestation = confirmed membership.

### Pool Schema Thought

Declares what thought types a pool uses — self-describing configuration.

```
{
  type: "pool_schema"
  content:
    name: "Party Tuesday"              // human-readable
    description: "Weekly coordination"
    required_aspects:
      - appetite                       // rate limiting config
      - membership                     // who can join
    optional_aspects:
      - expectations                   // pre-authorized contacts
      - transfer_rules                 // peer layer config
      - acceptance_rules               // local layer config
    aspect_schemas:
      appetite: <schema_cid>
      membership: <schema_cid>
      ...
  created_by: <pool_admin>
  because: [pool_cid]
}
```

**Why this matters:**

The pool CID is a hash. Humans need "Party Tuesday". More importantly: anyone joining the pool needs to know what config thoughts to look for.

The pool schema declares:
- Human-readable name
- What aspect types are required/optional
- Schema CIDs for each aspect type (how to interpret them)

**Discovery chain:**
```
Pool CID
    ↓ find pool_schema where because → pool
Pool Schema (declares required aspects, human name)
    ↓ references aspect_schemas
Aspect Schemas (how to interpret each config type)
    ↓ references
Meta-schema → Bootstrap terminal
```

Same self-describing pattern, applied to pool configuration.

### Redaction Thought

Signed retraction of content. The chain shows a hole; content is removed.

```
{
  type: "redaction"
  content:
    target: <original_cid>
    reason: "Personal request" | null
    replacement: "[REDACTED]" | null
  created_by: <same identity as original>
  because: [original_cid]
}
```

**Properties:**

- **Immutable chain**: Original CID still exists in because references
- **Auditable**: Redaction is a signed thought with its own CID
- **Verifiable**: Only the original creator can redact their own thought
- **Optional honoring**: Whether you respect the redaction is YOUR choice

**The chain shows the hole:**
```
thought_1 → thought_2 (REDACTED) → thought_3
                 ↑
           redaction_thought
             signed by original creator
```

**Honoring policy (your aspects):**
```
ASPECT: redaction_policy
  content:
    personal_pools: honor_always
    research_pools: honor_unless_security
    legal_audit: never_honor  // requirement to see everything
    default: honor
```

**Why optional honoring?**

Some contexts require full history:
- Legal discovery
- Security audit
- Compliance requirements

The redaction is a *request*. The graph preserves the fact something existed. Your policy decides whether to show content or "[REDACTED]".

**Not deletion**: The thought exists. The CID is in chains. You can see the shape of what was there. But the content can be obscured if you choose to honor it.

**Protocol vs enforcement:**

```
PROTOCOL:              "Conforming clients SHOULD honor redaction requests"
REFERENCE IMPL:        honor_redaction: true (default)
YOUR POLICY:           Based on your aspects and peering decisions
ENFORCEMENT:           Reputational, not cryptographic
```

The protocol recommends. Reference implementations comply. But ultimately it's your peering intelligence:

- Peer known to honor redactions → maintain trust
- Peer leaks redacted content → trust drops, maybe drop peer
- You need full history (legal/audit) → your policy, your liability

Like HTTP cache headers: the spec says `Cache-Control: no-store`, a bad client can ignore it, but they get a reputation. The network routes around bad actors.

**This is a social contract backed by reputation, not a cryptographic guarantee.**

### The Devices Pool Pattern

The first pool for any identity is their **devices pool** — the sync boundary for secrets.

```
HUMAN IDENTITY (Keif)
    │
    ├── creates POOL (keif-devices, private, admin: keif)
    │
    ├── DEVICE IDENTITY (Keif@laptop, managed, parent: keif)
    │       │
    │       └── CONNECTION: laptop → member_of → keif-devices
    │               ├── ATTESTATION by laptop (+1.0) "I want in"
    │               └── ATTESTATION by keif (+1.0) "Pool accepts"
    │
    ├── DEVICE IDENTITY (Keif@phone, managed, parent: keif)
    │       └── ... same bilateral attestation pattern
    │
    └── SECRETS (visibility: pool:keif-devices)
            ├── keif master secret
            ├── laptop secret
            └── phone secret
```

**Sync behaviour:**

| What | Where it syncs |
|------|----------------|
| Human identity | Everywhere (public) |
| Device identities | Everywhere (public) |
| Pool thought | Everywhere (public) |
| Membership connections | Everywhere (public) |
| Membership attestations | Everywhere (public) |
| Secrets | Only within pool members |

**Multi-head signing:** Each device signs as itself (`created_by: device_cid`), but all devices are managed under the same human identity. Trust chain: device → managed under → human.

**Revocation:** Admin attests -1.0 on membership connection. Device can still verify old thoughts but can't create new ones that will be trusted.

### Compromise Windows

Revocation isn't just "no more access" — it's "everything since &lt;timestamp&gt; needs review."

When a device is compromised (stolen, hacked, bad actor access), the response is:

```
1. REVOCATION ATTESTATION
   type: attestation
   on: membership_connection_cid
   weight: -1.0
   created_by: admin

2. COMPROMISE WINDOW MARKER
   type: aspect
   aspect_type: constraint
   domain: trust
   name: compromise_window
   applies_to: device_cid
   window_start: <when compromise began>
   window_end: <when detected>
   reason: "Phone stolen, unauthorized access"

3. FLAG AFFECTED THOUGHTS
   For each thought created by device within window:
     type: attestation
     on: thought_cid
     weight: 0.0  (neutral — needs review)
     via: compromise_marker_cid
```

**Trust recomputation:**

| Thoughts | Trust |
|----------|-------|
| Before window | Still trusted (device valid at creation) |
| Within window | Flagged 0.0 (requires manual review) |
| After revocation | 0.0 (membership revoked, no trust path) |

**Resolution options for flagged thoughts:**
- **Reject** (-1.0): "This was the bad actor"
- **Verify** (+1.0): "I actually wrote this"
- **Leave flagged** (0.0): "Can't determine, needs investigation"

**Downstream effects:** If Alice cited a thought from the compromise window, her thought's groundedness drops. She sees: "Warning: your source was flagged as potentially compromised." She can add her own attestation to verify independently or wait for resolution.

**Key insight:** Data is immutable. Trust is recomputable. The compromise marker stays forever — anyone walking the chain can see the history.

### Trail Bookmark Thought

A named entry point into a trail.

```
{
  type: "trail"
  name: string
  entry: thought_cid    // where the trail starts
}
```

**Named trails via IPNS**: The trail bookmark thought gets a CID. For stable naming, publish via IPNS:

```
IPNS name (derived from keypair) → trail bookmark CID

wellspring://keif/trail/turkish-bow
  ↓
IPNS resolution
  ↓
trail bookmark CID
  ↓
entry thought
  ↓
walk because chain (or follow connections by same creator)
```

The IPNS pointer is mutable. The trail content (CIDs) is immutable. Update the trail = new bookmark CID = update IPNS pointer.

---

## How Thoughts Compose

### The Merkle DAG

All thoughts form a Merkle DAG:

```
[Basic A]     [Basic B]
    ↑             ↑
     \           /
      \         /
    [Connection A→B]
           ↑
           │
    [Attestation]
           ↑
           │
    [Attestation of attestation]
```

Every node is a CID. Edges are `because` references and typed content references (from/to in connections, on/via in attestations).

**Properties from Merkle DAG structure**:

- **Immutable**: changing content changes CID, creates new node
- **Self-verified**: if you have the CID, you can verify the content
- **Deduplicatable**: same content = same CID everywhere
- **Syncable**: "do you have this CID?" is the only sync question
- **Acyclic**: hash functions prevent cycles

### Trail as Because Chain

A trail is not a separate data structure. It's the `because` chain walked backward.

```
Thought D
  because: [C]
     ↓
Thought C
  because: [B]
     ↓
Thought B
  because: [A]
     ↓
Thought A
  because: []  // terminal
```

Trail from D: D → C → B → A

Different people's trails through the same material are different `because` chains. Same content thoughts, different paths to them.

### Attestation Discovery

Attestations are not embedded in what they attest. They're separate thoughts that reference it.

```
"Find all attestations on Connection X"
  → query: thoughts where type=attestation AND on=X_cid

"Find all attestations by Keif"
  → query: thoughts where type=attestation AND created_by=keif_cid

"Find attestations on X by people I trust"
  → query: attestations on X, weighted by trust(creator)
```

This is the fundamental query pattern. Attestations accumulate over time as separate nodes. The connection itself never changes.

---

## Trust Computation

Trust is computed from the graph, not stored.

### Trust Formula

```
trust(source, observer, context, time) =
  f(vouch_chains, attestation_weights, because_depth)
```

### Vouch Chains

Trust flows through `vouches` connections:

```
keif → vouches → sarah (keif attests +0.9)
sarah → vouches → mike (sarah attests +0.7)

trust(mike, from keif's perspective) = 0.9 × 0.7 = 0.63
```

**Vouches are not transitive by default** — the product decays with chain length. You can configure trust policy per pool.

### Voucher Accountability

When a vouched identity misbehaves, consequences propagate back:

```
Bob (core, trust 1.0)
  └── vouches → Dave (0.8)
                  └── vouches → Eve (0.7)
                                  └── SPAMS

Consequences:
  Eve:  trust 0.0 (direct penalty)
  Dave: judgement penalty (vouched for spammer)
        - base trust unchanged
        - vouching power reduced 30%
  Bob:  judgement noted (vouched for Dave)
        - base trust unchanged (Dave's work was fine)
        - other attestations provide counter-evidence
```

**Judgement vs trust:** Your trust score (can I rely on your content?) is separate from your judgement score (can I rely on your vouches?). Bad vouches reduce vouching power, not necessarily content trust.

### Sybil Resistance

Creating fake accounts is easy. Making them trusted is expensive.

| Mechanism | Effect |
|-----------|--------|
| **Multiplicative decay** | 5 hops: 0.8^5 = 0.33 trust |
| **Voucher accountability** | Bad vouch → your reputation at stake |
| **Asymmetric cost** | Identity free, vouch costs social capital |
| **Audit trail** | "Why did you vouch?" has receipts |
| **Multiple observers** | Consensus from independent attestations |

**Attack cost analysis:**
```
Attacker creates 100 fake accounts
  → Needs 100 vouches (social capital cost each)
  → Each fake that misbehaves penalizes voucher
  → After ~5 bad vouches: voucher's power exhausted
  → Net: burns real reputation for temporary spam
```

The cost of Sybil attacks scales with the damage you can do. Low-trust fakes can't do much. High-trust fakes require burning real reputation.

### Brigading & Trust Network Sovereignty

Brigading (coordinated attacks by groups) isn't solved by the protocol — it's managed by **your choice of trust network**.

**The principle:** Your algorithm, your appetite.

```
WHAT WELLSPRING PROVIDES:
  - The graph (attestations, vouches, because chains)
  - Visibility into who attested what
  - Tools to compute trust from your perspective

WHAT YOU DECIDE:
  - Which pools to trust
  - Which vouchers to weight
  - How deep to follow vouch chains
  - What your waterline is
```

**Public trust ratings as shared pools:**

Pool operators can publish their trust assessments:

```
POOL: security-researchers-trust-ratings
  ATTESTATION: { on: alice_cid, weight: 0.9, via: "track-record" }
  ATTESTATION: { on: sketchy_account, weight: 0.1, via: "suspicious-pattern" }
  ...

You can:
  - Subscribe to this pool
  - Weight its ratings in your trust computation
  - Or ignore it entirely and build your own
```

**Web of trust is composable:**

| Approach | Example |
|----------|---------|
| Trust one curator | "I trust @security-bob's ratings" |
| Blend multiple | "Average of @alice, @bob, @carol ratings" |
| Build your own | "Only vouch chains through people I've met" |
| Paranoid mode | "Only my direct attestations count" |
| Open mode | "4-hop vouch chains, low threshold" |

**Brigading resilience options:**

1. **Velocity limits**: Sudden influx of attestations from new accounts → suspicious
2. **Cluster detection**: Many attestations from tightly-connected group → possible coordination
3. **Source diversity**: Require attestations from multiple independent vouch chains
4. **Time weighting**: Older attestations from established accounts count more
5. **Your waterline**: Just raise it during attacks, lower when calm

**The key insight:** There's no global "correct" trust. There's what you're willing to rely on. Someone else's brigade is your signal to check your sources. The graph gives you the data. You decide what to do with it.

### Visibility Without Trust

On current networks: **block = invisible**. You can't see what blocked accounts are doing.

In WoT: **visibility and trust are separate**. You can observe, peer into, and report on content you don't trust.

```
CURRENT NETWORKS:
  Block → content disappears from your view
  Result: can't see coordination, can't report patterns

WELLSPRING:
  Low trust → content visible, just weighted low
  Result: can observe, analyze, share findings
```

**Why this matters:**

| Scenario | Block Model | Trust Model |
|----------|-------------|-------------|
| Spotting coordination | Can't see it | Watch the pattern |
| Reporting bad actors | "Trust me, they're bad" | "Here's the evidence chain" |
| Research on manipulation | Requires unblocking | Always visible, just untrusted |
| Early warning | Blind until it hits you | See the buildup |

**Example: Observing and reporting a brigade**

```
You observe (no trust required):
  - 50 new accounts
  - All vouched by same 3 people
  - All attesting same content in 2-hour window
  - Pattern: coordinated

You create:
  THOUGHT: "Observed coordination pattern"
    because: [account1, account2, ..., account50]
    content: { analysis, timestamps, vouch graph }

Others can:
  - See your analysis
  - Verify your evidence (it's all CIDs)
  - Add to their trust computation
  - Or disagree with receipts
```

You don't need to block. You don't need to trust. You observe and report. The evidence speaks.

**"Block early, block often" → "observe, weight, share":**

| Old Model | New Model |
|-----------|-----------|
| Block (binary) | Weight (continuous) |
| Invisible | Visible but discounted |
| Personal only | Shareable analysis |
| No evidence | Full receipts |

The content stays in the graph. Your trust computation ignores it. But you — and others — can always look.

### Hello Handshake (Cold Start)

Two strangers, no prior chain, want to start talking.

**The pattern: out-of-band bootstrap + in-band verification.**

```
OUT-OF-BAND (any channel):
  1. Alice creates hello card:
     {
       wellspring: "hello/1.0",
       identity_cid: "cid:sha256:...",
       name: "Alice",
       pubkey: "ed25519:...",
       signature: <proves key ownership>
     }
  2. Shares via QR/email/text/in-person/business card
  3. Bob receives and verifies signature against pubkey

IN-BAND (WoT):
  4. Alice creates shared pool (private, participants: [alice, bob])
  5. Bilateral membership attestation
  6. First messages (grounded in pool membership)
```

**What each party has after handshake:**
- Verified identity of the other (cryptographic proof)
- Private communication channel (shared pool)
- Shared history (because chains begin)
- Zero external trust required

**Trust level:** Starts at zero — just identity verification. Trust grows from direct interaction. Later, they can vouch for each other (creates chain for others).

**Discovery options:**

| Channel | Trust Level | Example |
|---------|-------------|---------|
| In person | High | QR code, NFC tap |
| Verified contact | Medium | Known email, phone |
| Public directory | Low | Public hello-cards pool |

**Public hello pool:**

```
POOL: public-hello-cards (visibility: public)

THOUGHT by alice:
  type: "hello_card"
  content:
    identity_cid: alice.cid
    name: "Alice"
    interests: ["AI safety", "crypto"]
    pubkey: "ed25519:..."

Anyone can browse, verify pubkeys, initiate private handshake.
Trust = zero until you interact.
```

### Expectation Thoughts

Remote hello without physical presence: pre-authorize with an expectation.

```
SCENARIO: Alice wants to connect with Bob (remote)

OUT-OF-BAND:
  Alice emails Bob: "Here's my hello card, expecting yours"

IN-BAND (Alice):
  THOUGHT: "Expecting hello from Bob"
    type: "expectation"
    content:
      expecting_name: "Bob"
      expecting_channel: "email:bob@example.com"
      expires: "2026-02-01"
    because: [alice_identity]

When Bob's card arrives:
  - Matches expectation thought
  - Appetite satisfied → accept handshake
  - Create shared pool
```

**Trust levels by discovery:**

| Method | Expectation Needed | Appetite |
|--------|-------------------|----------|
| In-person QR | None | High (physical presence) |
| Expected remote | "Expecting X" thought | Medium (you initiated) |
| Cold outreach | None | Low (prove yourself) |

The expectation thought is your **pre-authorization**. Without it, random hello cards get low appetite. With it, you're saying "I'm waiting for this one."

### Rate Limiting by Appetite

You can never fully protect against input overflow — but you can auto-rate limit based on appetite and expectations.

```
INCOMING THOUGHT PROCESSING:

1. Check: is sender in my trust graph?
   YES → normal processing
   NO  → check expectations

2. Check: do I have an expectation for this sender?
   YES → elevated appetite, accept
   NO  → low appetite, queue or defer

3. Check: velocity from this sender
   NORMAL → process
   HIGH   → rate limit, flag for review

4. Check: global incoming rate
   NORMAL → process all
   HIGH   → prioritize by trust score
```

**Appetite as a thought:**

```
THOUGHT: "Current appetite settings"
  type: "aspect"
  aspect_type: "preference"
  content:
    unknown_sender_rate: 10/hour
    trusted_sender_rate: 1000/hour
    expectation_boost: 100x
    attack_mode: false  # if true, only trusted senders
```

Your appetite is configurable. Attack happens → raise barriers. Calm period → lower them. All visible, all auditable.

### Groundedness

How well-grounded is an attestation?

```
groundedness(attestation) =
  if because is empty:
    return base_groundedness (~0.1-0.3)
  else:
    recurse into because thoughts
    aggregate their groundedness
    weight by attestation strength
```

Deep `because` chains with trusted sources = high groundedness.
Empty `because` = floating assertion = low groundedness.

### Trust by Identity Type

| Identity Type | Trust Source |
|---------------|--------------|
| **Sovereign** (has keys) | Vouch chains from other sovereigns |
| **Delegated** (derived) | Parent's trust × delegation factor |
| **Record** (no keys) | Vouches from capable attesters |
| **External** (outside system) | Historical accuracy reputation |

---

## Pools

Everything lives in a pool. Your personal "pod" is just your private pool.

### Pool Operations as Thoughts

All pool operations are thoughts:

**Membership**:
```
CONNECTION: keif → member_of → pool:family
ATTESTATION by keif: +1.0 (I want to join)
ATTESTATION by admin: +1.0 (pool accepts)
```

**Permission**:
```
CONNECTION: keif → can_write → pool:family
ATTESTATION by admin: +1.0 (granted)
ATTESTATION by admin: 0.0 at later time (revoked)
```

**Federation**:
```
CONNECTION: pool:A → federated_with → pool:B
ATTESTATION by pool:A admin: +1.0
ATTESTATION by pool:B admin: +1.0
```

### Pool Visibility

| Visibility | Behavior |
|------------|----------|
| **public** | Listed in directories, anyone can request access |
| **unlisted** | Not listed, need link to find |
| **private** | Invitation only |

### Your Pod

Your personal pool (pod) is:
- Created with your identity
- You are sole admin
- Default home for all your thoughts
- Private until you publish elsewhere

Publishing = connection thought from your content to another pool:

```
CONNECTION: my_thought → published_to → pool:public
```

Original stays in your pod. Connection makes it visible elsewhere.

---

## Sync

Sync is not a separate protocol. Sync is the graph.

### Bilateral Attestation

Inspired by SNAP (Synchronized Network Accounting Protocol):

```
THOUGHT: sync_channel:keif-sarah
  type: sync_channel
  participants: [keif_cid, sarah_cid]

Every sync operation:

CONNECTION: thought_xyz → transmitted_via → sync_channel
ATTESTATION by keif: +1.0, at: T1 (I sent this)
ATTESTATION by sarah: +1.0, at: T2 (I received this)
```

**Sync status**:
- Both attested +1.0 = confirmed
- Only sender attested = pending
- Receiver attested -1.0 = disputed (check `because` for reason)

### Sync Queries

```
"What has Sarah acknowledged?"
  → attestations by sarah on transmitted_via connections

"What's pending?"
  → transmitted_via connections with only my attestation

"What did we disagree on?"
  → transmitted_via with conflicting attestations
```

### Content-Addressed Sync

Because everything is CIDs:

```
Me: "I have CIDs [A, B, C, D]"
You: "I have [A, B, E, F]"
Me: "Send me E, F"
You: "Send me C, D"
Done.
```

If we agree on a CID, we agree on everything it contains (Merkle property).

### Visibility-Aware Sync (Dogfood 021)

Sync respects visibility rules. Not everything syncs everywhere.

**Visibility rules at sync time:**

```
_can_share_with_peer(thought, peer_cid):
  1. visibility: null or "public" → ALWAYS sync
  2. visibility: "local_forever" → NEVER sync
  3. visibility: "pool:<cid>"    → sync if:
     - peer is member of that pool, OR
     - we have peering agreement for that pool
  4. visibility: "participants_only" → sync if:
     - peer is in content.participants list
  5. Unknown visibility → DON'T sync (safe default)
```

**Peering agreements:**

```
THOUGHT: peering_agreement
  type: "peering"
  content:
    peer: <peer_identity_cid>
    shared_pools: [pool_a_cid, pool_b_cid]
    transfer_limits: { rate: 1000/hr, priority: high }
  created_by: <my_identity>
  because: [peer_identity_cid, pool_a_cid, pool_b_cid]
```

You explicitly choose what pools to share with each peer. The agreement is itself a thought — auditable, revocable, queryable.

**Sync filter flow:**

```
┌─────────────────────────────────────────────────────────────────┐
│  PEER REQUESTS SYNC (sends bloom filter)                        │
└─────────────────────────────────────────────────────────────────┘
              │
              ▼
┌─────────────────────────────────────────────────────────────────┐
│  FIND MISSING (bloom filter check)                              │
│    For each thought I have:                                     │
│      if not in peer's bloom → candidate for sync                │
└─────────────────────────────────────────────────────────────────┘
              │
              ▼
┌─────────────────────────────────────────────────────────────────┐
│  FILTER BY VISIBILITY                                           │
│    For each candidate:                                          │
│      if can_share_with_peer(thought, peer_cid) → include        │
│      else → filter out (increment filtered_count)               │
└─────────────────────────────────────────────────────────────────┘
              │
              ▼
┌─────────────────────────────────────────────────────────────────┐
│  RESOLVE DEPENDENCIES                                           │
│    For each included thought:                                   │
│      if signing identity not in peer's bloom:                   │
│        include identity (if shareable)                          │
│    Order: identities first, then content                        │
└─────────────────────────────────────────────────────────────────┘
              │
              ▼
┌─────────────────────────────────────────────────────────────────┐
│  SEND THOUGHTS                                                  │
│    Peer receives, verifies signatures, stores                   │
│    Creates received_via provenance (local_forever)              │
└─────────────────────────────────────────────────────────────────┘
```

**Sync provenance:**

Track where you received each thought — your local audit trail:

```
THOUGHT: received_via
  type: "connection"
  content:
    connection_type: "received_via"
    thought: <thought_cid>
    via: <peer_identity_cid>
    received_at: <timestamp>
  created_by: <my_identity>
  because: [<thought_cid>, <peer_identity_cid>]
  visibility: "local_forever"  ← never syncs
```

Use cases:
- Debug sync issues (where did I get this?)
- Track peer reliability (who sends verifiable vs junk?)
- Re-request from known-good peer if verification fails
- Audit trail for compliance

---

## Salience and Waterline

### Salience Formula

```
salience(thought, observer, time) =
  reachability × confidence × heat × belief

Where:
  reachability = can we walk to it from current context?
  confidence   = product of attestation weights along path
  heat         = f(recency, traversal_frequency)
  belief       = observer's attestation (0 if none = no opinion)
```

### Waterline

Thoughts above the waterline are "conscious" — high salience in current context.

```
WATERLINE VIEW

  ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░ surface
  
  ○ BuyMaterials pricing bug      [0.92]
  ○ Wife's birthday next week     [0.88]
  ○ WoT spec v0.4          [0.85]
  
  ─────────────── waterline ───────────────
  
  ◌ Cosmos partition strategy     [0.45]
  ◌ Holiday booking               [0.32]
  
  ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░ depths
```

Context changes → waterline shifts → different thoughts surface.

---

## Emergent Ontology

The semantic web died on data entry. WoT: **agent proposes, human attests, ontology emerges**.

### The Cycle

```
BEHAVIOR (you do things)
    ↓
AGENT OBSERVES (patterns in your because chains)
    ↓
AGENT PROPOSES ASPECT (new aspect thought)
    ↓
HUMAN ATTESTS (+1, -1, refined, with because)
    ↓
ASPECT VALIDATED (or rejected with explanation)
    ↓
BETTER PREDICTIONS
    ↓
loops back
```

### Hierarchy from Attestation

```
Agent proposes:
  CONNECTION: likes-peri-peri → instance_of → enjoys-spicy

Keif attests: +1.0

Ontology grows:
  enjoys-spicy
    └── likes-peri-peri
```

No top-down schema. Structure emerges from use.

---

## Hierarchical Agent Architecture

WoT supports multi-level cognitive processing — from fast subconscious pattern matching to deliberate conscious attention.

### The Three Layers

```
┌─────────────────────────────────────────────────────┐
│  CONSCIOUS (You + Coordinator Agents)               │
│  - Full context, decision authority                 │
│  - Attests outputs from below                       │
│  - Sets aspects, manages pools                      │
│  - Response time: seconds to hours                  │
├─────────────────────────────────────────────────────┤
│  WORKING MEMORY (Pools as Debate Spaces)            │
│  - Spawned working areas for research/discussion    │
│  - Multiple agents collaborate                      │
│  - Trails captured, fully attributed                │
│  - Output: collapsed summary + full chain available │
│  - Response time: minutes to days                   │
├─────────────────────────────────────────────────────┤
│  SUBCONSCIOUS (1-bit LLMs / Fast Retrieval)         │
│  - Cheap, fast, local                               │
│  - Pattern matching, candidate retrieval            │
│  - No attestation authority                         │
│  - Surfaces candidates for layers above             │
│  - Response time: milliseconds                      │
└─────────────────────────────────────────────────────┘
```

### Subconscious Processing

1-bit quantized LLMs (BitNet) running locally on CPU provide instant pattern matching:

```
Query arrives
    ↓
1-bit LLM (local, ~0 cost, instant)
    ↓
"Here are 50 possibly-relevant CIDs"
    ↓
Bloom filter check (in trust graph?)
    ↓
"Here are 12 that pass trust threshold"
    ↓
Surface to working memory / coordinator
    ↓
Full verification if needed
```

The subconscious doesn't *decide* — it *retrieves*. No attestation authority. Just fast narrowing before expensive verification.

### Working Memory Pools

Pools can spawn temporary working areas for deliberation:

```
fn spawn_debate(parent_pool: &Pool, question: &Thought) -> Pool {
    let working_pool = Pool::new_child(parent_pool);
    working_pool.set_rules(PoolRules {
        auto_collapse: true,
        collapse_threshold: Duration::hours(24),
        require_consensus: 0.7,
    });
    
    // Spawn agents into working pool
    for agent in select_relevant_agents(question) {
        agent.join(working_pool);
    }
    
    // When done, output is single thought with because → full debate
    working_pool
}
```

The debate is the `because` chain. The output thought references it. **Complexity collapsed but available.**

### Multi-Agent Orchestration

Inspired by Gas Town (Yegge's multi-agent workspace manager):

| Concept | WoT Equivalent |
|---------|----------------------|
| Mayor (coordinator) | Conscious layer agent with full context |
| Polecats (workers) | Ephemeral agents spawned for tasks |
| Hooks (persistence) | Because chains surviving agent death |
| Convoys (work bundles) | Thought threads as grouped tasks |
| Beads ledger | Attestation graph as work tracking |

**Key principle**: Work persists in the graph, not in agent memory. Agent dies → trails remain → new agent picks up.

### Earned Autonomy

Agents earn expanded capabilities through demonstrated safe behavior:

```
Agent: research-bot-1
  initial_permissions:
    - read: [public_pools]
    - write: [own_working_pool]
    - attest: none
    
  after 100 verified outputs:
    - read: [public_pools, shared_research]
    - write: [own_working_pool, draft_submissions]
    - attest: [within_own_pool]
    
  after human attestation of quality:
    - read: [expanded]
    - write: [can_propose_to_main_pool]
    - attest: [provisional, requires_human_confirm]
```

Capability follows trust. Trust follows attestation. Attestation follows demonstrated behavior.

---

## Sovereignty Over Attention

WoT inverts the attention economy: **your algorithm, your responsibility**.

### The Problem

> "How do I get my version of the internet to stop showing me humans moments before their death?"

Current answer: "Tap I'm not interested" — reactive, per-item, Sisyphean.

Current systems optimize for *their* engagement metrics. You get what keeps you scrolling, not what you asked for.

### Your Algorithm

Aspects define what surfaces. Not their engagement algo — **yours**.

```
Mode: sunday-morning
  aspects:
    puppies: +2.0
    science-breakthroughs: +1.5
    world-news: -0.5
    conflict: -1.0
    
Mode: informed-citizen
  aspects:
    world-news: +1.0
    conflict: +0.5      # I need to know
    analysis: +1.0
    raw-footage: -1.0   # but spare me the gore
    
Mode: crisis-monitor
  aspects:
    all: +0.0           # waterline down, show me everything
```

Switch modes like switching gears. Sunday morning ≠ Monday morning ≠ "something just happened."

### Conscious Blinders

Every information diet is a choice. WoT makes the choice **visible** and **yours**.

Yes, you can create an echo chamber. You can also create a window. The difference is *you configured it* rather than having it configured for you by an algorithm that profits from your outrage.

"I want puppies" is a valid choice.
"I need to see this" is also a valid choice.
The same person, different moments.

| Current Systems | WoT |
|-----------------|-----------|
| One algo | Your algo |
| No knobs | Your knobs |
| Their responsibility | Your responsibility |
| Hidden optimization | Visible configuration |
| "I'm not interested" (reactive) | Aspects (proactive) |

### Delegated Algorithms

If you're an identity created down-chain under aspect rules from a higher identity, your algorithm can be controlled on your behalf:

```
Identity: parent-keif
  ├── aspects: self-sovereign
  ├── algo: my responsibility
  │
  └── creates: Identity: child-1
        ├── aspects: inherited + restricted
        ├── algo: controlled by creator
        ├── graduation_criteria: age OR attestation
```

The restriction is **visible**. Not hidden parental controls, but explicit rules with a path to graduation.

---

## Managed Identities

Not all identities are self-sovereign. Some are created, supervised, and graduated.

### Identity Hierarchy

```
Identity: Keif (sovereign)
  ├── full key ownership
  ├── self-determined aspects
  │
  └── creates → Identity: child-1 (managed)
        ├── keys held in escrow or derived
        ├── aspects: inherited + parent-imposed
        ├── algo: parent-controlled
        │
        └── can create → Identity: child-1-school-project (scoped)
              ├── further restricted
              └── inherits restrictions from chain
```

### Autonomy Levels

| Identity Type | Algo Control | Key Ownership | Graduation Path |
|--------------|--------------|---------------|-----------------|
| Sovereign | Self | Full | Default state |
| Managed (child) | Parent | Escrow | Age + attestation |
| Managed (employee) | Company policy | Delegated | Tenure + role |
| Managed (AI agent) | Creator constrains | None | Evaluation + earned trust |
| Scoped (temporary) | Inherited | Session | Task completion |

### Graduation

Managed identities can graduate to higher autonomy:

```
ATTESTATION by parent-keif:
  on: child-1
  aspect: ready-for-autonomy
  weight: +1.0
  because: [observed-responsible-behavior, age-threshold-met]
  
Result: child-1 gains expanded permissions
```

The attestation is on-chain. The reasoning is in the `because`. Transparent authority.

---

## Multi-Party Pool Oversight

Pools can have multiple stakeholders with different roles in identity permission management.

### Permission Lifecycle

```
Identity: child-1
  Pool: soccer-team-u12
    granted_by: coach
    observed_by: [coach, parent-keif, parent-spouse]
    revocable_by: [coach, parent-keif, parent-spouse]  # ANY can pull
    
  Pool: school-classroom-6b
    granted_by: teacher
    observed_by: [teacher, parent-keif, parent-spouse, headteacher]
    revocable_by: [teacher, parent-keif, parent-spouse]
    
  Pool: family-chat
    granted_by: parent-keif
    observed_by: [parent-keif, parent-spouse, grandma]
    revocable_by: [parent-keif, parent-spouse]
```

### Governance Patterns

| Scenario | Grant | Observe | Revoke |
|----------|-------|---------|--------|
| Child in school | Teacher | Teacher + Parents | Any |
| Employee in project | Manager | Manager + Compliance | Any |
| AI agent in prod | DevOps | DevOps + Security + Exec | Any (kill switch) |
| New community member | Existing member | Moderators | Moderators OR sponsor |

### Asymmetric Operations

**Key insight**: Revocation is OR (any party can pull), expansion is AND (requires consensus).

```
Grant permission:  requires attestation from ALL authorized granters
Revoke permission: requires attestation from ANY authorized revoker
```

Fail-safe, not fail-open. Easy to constrain, hard to expand.

### Audit Trail

Every permission change is a thought with a `because` chain:

```
ATTESTATION by teacher:
  on: [child-1 → member_of → classroom-pool]
  weight: -1.0  # revocation
  because: [incident-report-xyz, policy-violation]
```

Dispute resolution has receipts. "Why was I removed?" has an answer.

---

## Implementation Notes

### Language Choice: Rust + WASM

The core library should be Rust, compiled to multiple targets:

```
┌─────────────────────────────────────────────────────┐
│              libwellspring (Rust)                   │
├─────────────────────────────────────────────────────┤
│  ┌─────────┐  ┌─────────┐  ┌─────────┐  ┌────────┐ │
│  │ Native  │  │  WASM   │  │  WASM   │  │ Python │ │
│  │ daemon  │  │ browser │  │  edge   │  │ PyO3   │ │
│  └─────────┘  └─────────┘  └─────────┘  └────────┘ │
│       │            │            │            │      │
│   Desktop      Browser      Cloudflare    Jupyter  │
│   Mobile       Artifacts    Workers       Scripts  │
│   Server       Extensions   Deno Deploy            │
└─────────────────────────────────────────────────────┘
```

**Why Rust:**
- Sub-microsecond latency for salience checks at thought-speed
- No GC pauses for long-running daemons
- Memory safety without runtime cost
- Ecosystem alignment: libp2p, iroh (Rust IPFS), SpacetimeDB
- serde for serialization (compile-time validation, zero-copy)
- Clean WASM compilation

**WASM implications:**
- Browser client verifies trust chains locally — no server trust required
- Artifacts carry their own validators
- Edge compute runs same codebase as desktop
- One implementation, every runtime

### Self-Describing Packet Format

Thoughts travel in self-describing packets:

```
┌─────────────────────────────────────────────┐
│ HEADER (fixed size, ~64 bytes)              │
├─────────────────────────────────────────────┤
│ magic: u32        "WLSP"                    │
│ version: u16      protocol version          │
│ flags: u16        compression, encryption   │
│ schema_cid: [u8; 32]  reference to schema   │
│ payload_type: u8  inline | reference        │
│ payload_len: u32  size of payload           │
│ trust_anchor: [u8; 32]  nearest repeater    │
│ hop_count: u8     for TTL/decay             │
├─────────────────────────────────────────────┤
│ PAYLOAD                                     │
│ - If inline: serialized thought             │
│ - If reference: CID + location hints        │
├─────────────────────────────────────────────┤
│ SIGNATURE (64 bytes)                        │
│ ed25519 over header + payload               │
└─────────────────────────────────────────────┘
```

**Features:**
- Schema CID in header → reader fetches schema if unknown
- Trust anchor → verify to nearest checkpoint, not full chain
- Hop count → natural TTL and decay metric
- Payload type → know before parsing if fetch required

### SpacetimeDB Learnings

Key patterns to adopt from SpacetimeDB architecture:

| SpacetimeDB | WoT Application |
|-------------|----------------------|
| SQL subscriptions | Aspect/trust filter subscriptions |
| Delta computation | Only sync changed attestations |
| Client-side cache | Local thought graph as truth |
| Reducers (only mutation) | Attestation creation as only mutation |
| Type macros | serde derives for self-describing schemas |
| In-memory + WAL | Hot graph in memory, CID store for persistence |

**Delta sync** is critical: don't re-send the whole graph. Client declares interest (aspects, trust thresholds, creators), server pushes only changes.

### Gossip Protocol Sketch

For P2P sync without central server:

```
Round N:
  Pick random peer from trust graph
  Exchange bloom filter of recent CIDs
  Identify deltas (they have / I don't, I have / they don't)
  Request missing CIDs
  Verify attestation chains on receipt
  Merge to local graph

Heat = # of rounds since last touch
Decay = natural from gossip round counting
```

**Properties:**
- No consensus needed — just propagation
- CIDs are self-verifying (forgery impossible)
- Trust graph determines who you gossip with
- Bloom filters make negotiation cheap

### Storage

Everything is a CID. Storage is:
- **IPFS**: distributed, content-addressed, pin what you want
- **IPNS**: mutable pointers for stable naming (identities, trail bookmarks)
- **Local index**: SQLite or similar for fast queries (salience, attestation lookup)

### CDN Peering Layer

Thoughts flow through a peering layer that separates transport from storage:

```
Your Device ←→ Local Cache ←→ Peer CDN ←→ IPFS Pinning
     │              │              │            │
   hot graph     warm sync    thought relay   cold storage
```

**Peer CDN properties:**
- Caches popular thoughts by CID (cache-friendly: immutable content)
- Routes gossip between peers without storing full graph
- Validates signatures at ingress (reject malformed before propagation)
- Tracks heat metrics for prioritised relay

**Why CDN suits WoT:**
| Web CDN | WoT CDN |
|---------|---------|
| Cache by URL | Cache by CID (content-addressed = perfect cache keys) |
| TTL expiry | No expiry (immutable), evict by heat decay |
| Edge nodes | Peer relays (anyone can run one) |
| Origin pull | IPFS fallback for cold CIDs |

**Peering economics:**
- Free tier: best-effort relay, rate-limited by sender reputation
- Paid tier: guaranteed bandwidth, priority routing, analytics
- Peer-to-peer: direct connections bypass CDN entirely (local network, trusted peers)

**Rate limiting at peer layer:**
```
Incoming thought:
  1. Check sender reputation (vouch chain from known identities)
  2. Check receiver appetite (expectation thoughts)
  3. Unknown sender + no expectation → queue, rate-limit
  4. Known sender OR expected → immediate relay
  5. Attack pattern detected → reject at edge
```

The CDN layer absorbs flood attacks. Your device only sees what passes your appetite filter.

### Peer Agreements (BGP for Thoughts)

Each peer relationship is its own pool with bilateral config. Like BGP autonomous systems negotiating routes.

```
PEER AGREEMENT POOL: alice ↔ fastcdn.wot
    │
    ├── alice's config (visibility: pool)
    │     inbound_rate: 10000/hour
    │     priority: high
    │     trust_relay: true   ← "I trust your sig verification"
    │
    ├── fastcdn's config (visibility: pool)
    │     outbound_rate: 10000/hour
    │     sla: 99.9%
    │     because: [service_agreement_cid]
    │
    └── bilateral attestation: "we agree on these terms"
```

**Different peers, different agreements:**

| Peer Type | Rate | Priority | Trust Relay | Notes |
|-----------|------|----------|-------------|-------|
| Premium CDN | 10000/hr | high | yes | Paid SLA, fast path |
| Community relay | 1000/hr | medium | verify | Best-effort, check sigs |
| Public pool | 100/hr | low | no | Drive-by spammers expected |
| Direct peer | unlimited | highest | yes | Trusted friend, no intermediary |

**BGP parallels:**

| BGP Concept | WoT Equivalent |
|-------------|----------------|
| Route announcements | Thought relay preferences |
| AS path | Because chains (provenance) |
| Route filtering | Appetite + expectations |
| Peering agreements | Bilateral pool attestations |
| BGP communities | Aspect tags for routing hints |
| Route poisoning | Negative attestations propagate |

**The peering agreement IS the contract:**
- Terms are thoughts in a shared pool
- Both parties attest agreement
- Breach? The attestation trail is evidence
- Renegotiate? New config thought with `because → previous`

**Config visibility:**
```
Your devices pool (private)
    └── appetite aspects
    └── expectations
    └── attack mode

Peer agreement pool (bilateral)
    └── your rate offers
    └── their rate offers
    └── mutual attestation
```

Your internal config stays in your devices pool. Peer-facing config goes in the agreement pool. Same primitive, different visibility.

### Transfer vs Acceptance (Two Rulesets)

Critical distinction: peer agreements control *transfer capacity*, not *belief*.

```
PEER LAYER (transfer)              LOCAL LAYER (acceptance)
─────────────────────              ────────────────────────
Rate: 100k/min                     Index if: trust > 0.5
Priority: high                     Buffer if: trust 0.1-0.5
Relay trust: yes/no                Discard if: trust < 0.1
```

**Flow:**
```
INCOMING THOUGHT (from peer)
     │
     ├─► Peer layer: "Do I have capacity from this peer?"
     │      No  → reject at edge (over rate limit)
     │      Yes → accept transfer
     │
     └─► Local layer: "Do I trust this content?"
            │
            ├─► trust > 0.5:     INDEX (surfaces immediately)
            │
            ├─► trust 0.1-0.5:   BUFFER (verification queue)
            │      → run extra checks
            │      → wait for more attestations
            │      → maybe promote later
            │
            └─► trust < 0.1:     DISCARD (or cold storage)
```

**Why this matters:**

You might accept 100k thoughts/minute from a premium CDN — that's the pipe capacity. But you only *index* the ones meeting your trust threshold. The rest go to a buffer for local verification or get discarded.

| Peer Agreement Says | Local Acceptance Says |
|---------------------|----------------------|
| "Accept 100k/min from fastcdn" | "Index only if trust > 0.5" |
| "Accept 1k/min from public-relay" | "Buffer 0.1-0.5 for verification" |
| "Accept unlimited from direct-peer" | "Still apply trust threshold" |

**The firehose is options, not beliefs.**

A high-bandwidth peer gives you candidates. Your local verification decides what you actually keep. The peer agreement is about logistics; acceptance criteria is about epistemology.

**Config locations:**
```
Devices pool (private)
    ├── acceptance thresholds (what you believe)
    ├── verification rules (extra checks for buffer zone)
    └── appetite aspects (attack mode, etc.)

Peer agreement pool (bilateral)
    ├── transfer rates (bandwidth)
    ├── priority levels (queue ordering)
    └── relay trust (sig verification delegation)
```

### Query Patterns

```
"All attestations on thought X"
  → WHERE type=attestation AND content.on = X

"My because chain from thought Y"
  → recursive walk: Y.because → each.because → ...

"Thoughts by creator Z in pool P"
  → WHERE created_by = Z AND published_to includes P

"Trust score for identity I"
  → walk vouch chains, multiply weights, apply decay
```

### CRDT Properties

Natural conflict-free replication:
- Thoughts: immutable, content-addressed → no conflict
- Attestations: append-only, different creators → set union
- Trust: computed, not stored → no conflict

---

## Scale Independence

The same primitives work at every scale. No migration needed as you grow.

### From Kitchen Table to Solar System

| Scale | What Changes | What Stays Same |
|-------|--------------|-----------------|
| **Solo notebook** | Local storage only | Thoughts, because chains, schemas |
| **Family/team** | Add sync, shared pools | Same primitives |
| **Organization** | Add trust hierarchies | Same primitives |
| **Internet-scale** | Add gossip, repeaters | Same primitives |
| **Interplanetary** | Add latency tolerance | Same primitives |

### Why This Works

**Content addressing**: CIDs are universal. Same hash in your kitchen, same hash on Mars.

**Self-describing**: No central schema registry. Carry your own decoder.

**Trust is local**: You compute trust from your perspective. No global consensus needed.

**Latency tolerance built in**: Because chains don't require synchronous verification. Verify when you can.

**Eventual consistency is fine**: Thoughts are immutable. Attestations accumulate. No coordination problem.

### Interplanetary Considerations

```
Earth Pool ←──────────────────────→ Mars Pool
           4-24 minutes each way

- Sync via periodic gossip bursts
- Trust anchors (repeaters) cache verification
- Because chains verify offline
- Attestations accumulate asynchronously
- Local pools operate independently
- Cross-pool connections when sync completes
```

The architecture doesn't assume instant connectivity. It assumes **eventual connectivity** and **local-first operation**. This happens to also work great for:
- Offline mobile
- Intermittent networks
- Air-gapped secure environments
- Post-disaster recovery

### Start Now, Scale Later

You can begin today with a text file on your laptop. The format is the format. When you're ready to sync with others, the thoughts don't change — you just add transport.

```
Day 1:    Local .jsonl file, manual backup
Day 30:   Git sync with collaborators
Day 90:   IPFS pinning, public pools
Day 365:  Running your own repeater
Day ???:  Mars relay node
```

Same thoughts. Same schemas. Same because chains. Same signatures.

---

## Economic Model: Why Open Protocol

### Why TCP/IP Won

> "Its simple design, focus on end-to-end reliability, and superior interoperability allowed it to dominate."

| TCP/IP | WoT |
|--------|-----------|
| Simple design | One primitive: Thought |
| End-to-end reliability | CID verifies content, signature verifies source, because chain verifies reasoning |
| Interoperability | Self-describing schemas, any tool reads/writes, no lock-in |

### The Problem Being Solved

**I can't keep track of what I know, why I know it, who told me, and what I should be paying attention to right now.**

Every knowledge worker hits this daily. Every AI agent hits this every session.

| Current State | Problem | WoT |
|---------------|---------|------------|
| Info organized around storage | "Where did I put it?" | Organized around traversal — "How did I get here?" |
| Context evaporates | "Why did I save this?" | Because chains preserve the path |
| Trust is implicit | "Should I believe this?" | Attestations make it explicit |
| Machines serve platforms | Your attention optimized for their engagement | Your algo, your salience |
| Apps silo knowledge | Can't connect across tools | Thoughts portable, tools are views |
| AI is stateless | Every conversation from zero | Trails persist, agents continue |

### Getting Started

```bash
docker run wellspring/1.0.0
```

```markdown
# Quick Start (< 1 page)

1. Create a thought
   $ ws thought "TCP/IP won because simple design + reliability + interop"
   
2. Add a because
   $ ws thought "WoT follows same pattern" --because [previous-cid]
   
3. Attest
   $ ws attest [cid] +1.0 "I verified this"
   
4. See your trail
   $ ws trail [cid]
   
5. Share a pool
   $ ws pool create "my-public-learnings" --public
   $ ws publish [cid] --to my-public-learnings

You're on the network.
```

### The Self-Growing Loop

```
THOUGHT
  ↓
DECISION (attested: "I chose X because [chain]")
  ↓
ACTION in real world
  ↓
OUTCOME (observable)
  ↓
NEW THOUGHT (because → original decision)
  ↓
REVIEW: did that reasoning work?
  ↓
BETTER FUTURE DECISIONS
  ↓
loops back
```

The more you use it, the more trails exist. The more trails, the better surfacing. The better surfacing, the better decisions. The better decisions, the more you trust it.

### Network Effects Without Lock-in

```
You make good calls
  ↓
Your because chains are solid
  ↓
Others attest to your judgement
  ↓
Your attestations carry more weight
  ↓
Others follow trails you've walked
  ↓
They make compatible trails
  ↓
Graph grows
```

TCP/IP didn't need marketing. It needed to work, and people using it needed to connect. The network grew because connecting was more valuable than not connecting.

WoT's version: if your trails are useful, others want to walk them. If walking trails is useful, others make trails. The network grows because **shared reasoning is more valuable than isolated notes**.

### Protocol vs Service Layer

The protocol has no business model. That's the feature.

```
PROTOCOL LAYER (free, open)        │  SERVICE LAYER (competitive)
───────────────────────────────────┼────────────────────────────────
Thoughts, CIDs, because chains     │  Pool hosting
Attestations, schemas              │  Managed algo feeds
Trust computation                  │  Persistence pinning
                                   │  Negotiation agents
                                   │  Index/search/discovery
                                   │  Bootstrap consulting
                                   │  CDN peering (priority tiers)
                                   │  Guaranteed delivery SLAs
                                   │  Analytics & reputation dashboards
```

### Service Layer Economics

Providers compete on quality, not lock-in. All data remains portable.

**Tiered CDN Peering:**
```
FREE TIER                          PAID TIER
────────────────────               ────────────────────
Best-effort relay                  Guaranteed bandwidth
Rate-limited (10/hour unknown)     Priority queue
Basic reputation check             Advanced filtering
Community support                  SLA with uptime guarantee
No analytics                       Full relay analytics
```

**Provider specialisation:**
| Service | Value Add | Pricing Model |
|---------|-----------|---------------|
| High-availability pinning | 99.9% uptime, multi-region | Storage + egress |
| Managed algo feeds | Curated salience, topic filtering | Subscription |
| Search & discovery | Full-graph indexing, semantic search | Query volume |
| Negotiation agents | Automated coordination, calendar bots | Per-negotiation |
| Identity bootstrap | KYC bridge, reputation transfer | One-time + attestation |
| Enterprise pools | Compliance, audit trails, SSO | Per-seat |

**Why this works:**
- **No data hostage**: Export everything, any time. CIDs are universal.
- **Compete on service**: Same protocol, different quality of delivery.
- **Natural pricing**: Pay for convenience, not for access to your own data.
- **Race to quality**: Providers who lose trust lose customers instantly.

**Revenue flows:**
```
User ──────► Free tier (rate-limited, best-effort)
     │
     └─────► Paid tier ────────► Provider revenue
                 │
                 ├── Priority relay
                 ├── SLA guarantees
                 ├── Analytics
                 └── Support
```

The protocol stays open. Services compete. Users win.

### Why Monopolies Are Hard

| Moat Attempt | Why It Fails |
|--------------|--------------|
| Hoard data | Public pools crawlable, private pools user-controlled |
| Lock-in formats | Self-describing, export everything |
| Network effects on graph | Your graph is yours, portable |
| Exclusive features | Protocol open, anyone implements |

Only durable advantage: **be better, faster, more trusted**.

### Negotiation Agents (Example Service)

```
Andy's bot                              Keif's bot
    │                                       │
    ├── releases: Saturday 2-5pm ──────────►│
    │◄─────── releases: Saturday 3-6pm ────┤
    ├── proposes: Saturday 3-5pm ──────────►│
    │◄─────── accepts ─────────────────────┤
    ▼                                       ▼
keif-andy-kids-playdates pool
  └── ATTESTATION: Saturday 3-5pm confirmed
      attested_by: [andy-bot, keif-bot]
```

Coordination without coordination tax.

### Launch Path

You don't need to convince anyone of the philosophy. You need **one working trail** that someone else wants to follow.

```
Phase 1: Works for you (daily use, real friction solved)
Phase 2: Share trails publicly (proof it works)  
Phase 3: Someone wants to verify/extend your reasoning
Phase 4: They need compatible tools
Phase 5: Tools emerge to connect
Phase 6: Network grows
```

Bootstrap is always the problem. Low barrier to entry is the solution.

---

## Summary

```
┌─────────────────────────────────────────────────────────┐
│                                                         │
│  WoT: Wellspring of Thoughts — v0.6                     │
│                                                         │
│  "Water remembers every path it has taken"              │
│                                                         │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  One primitive:                                         │
│    THOUGHT (CID) — content-addressed, signed, grounded  │
│                                                         │
│  Thought types (content schemas):                       │
│    basic       — string or structured content           │
│    identity    — pubkey, self-referential, can be       │
│                  managed/delegated/scoped               │
│    connection  — from/to/relation between thoughts      │
│    attestation — belief about any thought               │
│    aspect      — value/preference/constraint/algo       │
│    pool        — container with multi-party oversight   │
│    trail       — named entry point (IPNS → CID)         │
│                                                         │
│  Key fields:                                            │
│    created_by  — always attributed                      │
│    because     — what led here (with content selectors) │
│    signature   — cryptographic proof                    │
│    schema_cid  — how to interpret this thought          │
│                                                         │
│  Self-describing all the way down:                      │
│    Thought → Schema → Meta-schema → Bootstrap → Human   │
│    No external software needed to decode                │
│    Inline bootstrap for archival (Rosetta principle)    │
│    Language-independent terminals                       │
│                                                         │
│  Cognitive layers:                                      │
│    Conscious   — coordinator agents, full context       │
│    Working     — debate pools, multi-agent collab       │
│    Subconscious— 1-bit LLMs, fast retrieval, no attest  │
│                                                         │
│  Attention sovereignty:                                 │
│    Your algo   — aspects define what surfaces           │
│    Your modes  — switch context, switch salience        │
│    Your choice — blinders are visible, configurable     │
│                                                         │
│  Identity governance:                                   │
│    Sovereign   — self-determined, full keys             │
│    Managed     — parent-controlled, graduation path     │
│    Scoped      — temporary, inherited restrictions      │
│                                                         │
│  Pool oversight:                                        │
│    Grant       — requires authorized granters           │
│    Observe     — multiple stakeholders watch            │
│    Revoke      — ANY authorized party can pull          │
│                                                         │
│  Implementation:                                        │
│    Rust core   — speed, safety, WASM compilation        │
│    Local-first — verify without network trust           │
│    Delta sync  — only changes, not whole graph          │
│    Gossip      — P2P propagation, no consensus needed   │
│                                                         │
│  Economic model:                                        │
│    Simple design  — one primitive, self-describing      │
│    End-to-end     — CID + signature + because = verified│
│    Interop        — any tool reads/writes, no lock-in   │
│    Low barrier    — docker run, < 1 page to start       │
│    Self-growing   — useful trails attract followers     │
│                                                         │
│  Properties:                                            │
│    Nothing anonymous    — created_by required           │
│    Nothing deleted      — append-only                   │
│    Nothing truly lost   — reachable if you have path    │
│    Everything weighable — trust always computable       │
│    Everything auditable — signatures + because chains   │
│    Autonomy is earned   — capability follows trust      │
│    Scale independent    — kitchen table to solar system │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

---

## Use Cases & Battle Testing

### Code Provenance (The Booch Problem)

Grady Booch (architect of UML, long-time industry figure) describes a recurring issue with AI-assisted coding:

> "I asked it to refactor a bit of code, being very specific about the pattern I wanted it to emulate, but in so doing it imported various libraries for Cloudflare which was absolutely insane because not once did I ever mention that infrastructure as part of my context nor was it at all relevant to the pattern."

The problem: AI pattern-matches from training data. Cloudflare appeared in similar contexts during training, so Claude mindlessly imported it. Without human review, that code stays — "harmless but useless, unnecessary, distracting, and perhaps disturbing."

He also notes: "Claude often failed to clean up bits of abandoned or backtracked work, yielding not insignificant amounts of dead code, duplicated code, and downright tortuously messy code."

His solution: "I choose to read all the code Claude produces, because while I know that the code is the truth, it is not the whole truth."

**WoT angle:** Every code contribution has a because chain. A commit shows:
- `created_by: claude-agent`
- `attested_by: ???`

If the attestation is empty or missing, it doesn't merge. The Cloudflare import would be visible: "Why is this here? What's the because?" If the answer is "pattern matching from training data" with no contextual justification, it's flagged.

This doesn't prevent AI from suggesting — it prevents unreviewed suggestions from becoming trusted. The debt is visible, not hidden in the walls.

### Earned Autonomy (The Latch Architecture)

An emerging pattern for agent infrastructure: capability increases only when constraints and verification are already in place.

Principles observed:
- **Least privilege by default**: Agent runs as non-root. No irreversible actions (merges, deletes, force-pushes) without explicit approval.
- **Public policy, private authority**: Policy constraints live in a public repo. The daemon handling execution stays private.
- **Signed automation**: Webhooks are HMAC-verified and repo/event allowlisted. Everything logged with receipts.
- **Dry-run gates**: No real operations until simulation passes.
- **Observability first**: Structured JSON logs for every decision and action path.

The agent earns expanded permissions through demonstrated safe behaviour — evaluation precedes capability.

**WoT mapping:**
- Public policy → Pool rules
- Signed automation → Attestation requirement
- Earned permissions → Trust graph expansion
- Receipts → Because chains

### AI Slop Detection (The BitNet Thread)

Someone posts: "Microsoft FINALLY open-sourced their 1-bit LLM framework!"

Gets ratio'd: "It's not 'finally' — you're referring to the release 2 weeks ago. They open sourced it 2-3 years ago. This is why I hate when people use AI for everything. You're just exposing yourself as a doofus who cannot check facts."

The receipts were right there in the changelog.

**WoT angle:** If that post required attestation, either:
1. The poster checks facts before signing (skin in game)
2. The poster signs anyway and their reputation absorbs the hit

Attestation doesn't prevent mistakes — it makes them attributed. Your name is on the chain, forever, immutably.

### Service Discovery via Trail Negotiation

Traditional: Central registry, query for service, trust the response.

With WoT: Agent broadcasts query to multiple sources. Each responds with CID-linked answer including their reasoning chain. Your agent verifies chains before presenting. You choose based on trust path, not SEO ranking.

The negotiation IS the protocol. No central registry required. Lighter than blockchain because you're proving lineage, not consensus.

---

## Open Questions

- **Compute-over-data model for pools** — Pools could enable remote processing where agents bring computation to the data rather than data to the computation. Agent services request compute permission on pools they have access to; processing runs in place; results are attested locally. Implications for trust economics, revocability, and agent reputation scoring for specific capabilities.

- **Grassmann flows as geometric salience model** — The paper "Attention Is Not What You Need: Grassmann Flows as an Attention-Free Alternative for Sequence Modeling" (arXiv:2512.19428, December 2025) proposes replacing attention mechanisms with flows on Grassmann manifolds. The core insight: instead of computing salience via heuristics (reachability × confidence × heat × belief), model the active trail as a k-dimensional subspace in embedding space. Salience becomes geometric alignment — how well a candidate thought projects onto the current cognitive subspace. Implementation would be: (1) embed thoughts via E5-small-v2 (already planned), (2) weight trail embeddings by trust/recency/heat, (3) SVD to extract k basis vectors, (4) salience = projection norm. This is computationally cheap (SVD on ~20 vectors, dot products) and runs locally. Further investigation needed on: whether geometric salience outperforms heuristics in practice, collaboration metrics via subspace angle between different users' trails through shared DAGs, and potential for training personal models on attested trail trajectories rather than scraped text. The Grassmann framing also offers interpretability — the subspace IS the current cognitive state, not an opaque tensor.

- **Thoughts as linking layer to arbitrary content** — A thought need not contain its content directly. The content field could be a reference to an IPFS CID containing the actual payload (document, image, video, dataset, code, anything). The thought becomes a metadata wrapper: attribution (created_by), provenance (because), timestamp, signature, and a pointer to content. This separates the semantic graph (thoughts + connections + attestations) from the content storage layer (IPFS). Benefits: deduplication (same content, different thoughts with different attribution/context), content-type agnosticism (the graph doesn't care what the bytes are), and cleaner separation of concerns. The thought layer is pure linking and attestation; IPFS handles storage and retrieval.

- **WoT as consent-native training corpus** — The AI industry faces a data cliff: high-quality, human-generated text for training is running out, and the "scrape now, apologize later" era is ending. WoT data is structurally different: every thought is attributed (created_by), grounded (because chains), signed (cryptographic proof), and permissioned (pool visibility). Training on WoT trails means training on consented, verified, human-attested reasoning paths — not scraped text of unknown provenance. Users control their pools; licensing is explicit. This aligns with emerging calls for "consent-driven, archivally informed" AI training partnerships. The trails aren't just data — they're witnessed cognition with receipts.

- **Bloom filters for hot path optimisation** — Rotating bloom filters could accelerate several operations: heat tracking (has this CID been touched recently?), sync negotiation (which CIDs do we share without exchanging full lists?), trail membership (is X in my active context?), and waterline pre-filtering (skip salience computation entirely for definitely-cold thoughts). False positives acceptable in all cases — worst case is unnecessary work. Rotation provides natural heat decay without explicit timestamp bookkeeping. Implementation detail, but architecturally relevant for performance at scale.

- **Surfacing and retrieval strategy** — Open question: how do you quickly find the right thoughts together? Current options: (1) Graph traversal from current context (hops) — expensive, doesn't scale to large graphs. (2) Vector similarity on embeddings — fast, but loses provenance and attestation weighting. (3) Grassmann projection — geometric, honours trail context, but requires embedding layer. (4) Hybrid — bloom filter for hot candidates, vector similarity for rough ranking, graph traversal for final grounding check. The tension is between speed (vector search) and groundedness (graph structure). Need to determine: is hop distance even the right metric? Does salience need to factor in trust chains? How much can be precomputed vs. query-time?
- Detailed sync protocol message formats
- Query language formal grammar
- API surface specification
- Salience algorithm tuning
- IPNS resolution latency and offline behaviour
- Key rotation ceremony
- Pool permission inheritance rules
- Browser extension architecture
- Mobile capture strategies

---

*WoT: Wellspring of Thoughts — v0.6*
*Keif Gwinn & Claude, January 2026*
*Building on Kushim's receipts (3400 BCE), Bush's Memex (1945), completing the 5,000-year vision*
